<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦想.家</title>
  <icon>https://www.gravatar.com/avatar/6b78864cdc121c419ba02197f9fd1c70</icon>
  <subtitle>非宁静无以致远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wuhuan.me/"/>
  <updated>2018-11-07T06:16:09.914Z</updated>
  <id>https://www.wuhuan.me/</id>
  
  <author>
    <name>梦想.家</name>
    <email>post.thinking@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git使用笔记</title>
    <link href="https://www.wuhuan.me/2018/03/15/git-use-note/"/>
    <id>https://www.wuhuan.me/2018/03/15/git-use-note/</id>
    <published>2018-03-15T12:00:00.000Z</published>
    <updated>2018-11-07T06:16:09.914Z</updated>
    
    <content type="html"><![CDATA[<p>git、github使用过程中记录的一些笔记，遇到的问题及其解决办法。</p><h2>1、创建SSH密匙</h2><p>这步工作应该是最麻烦的吧。回到桌面，打开git bash，输入以下命令。 <code>ssh-keygen -C 'your@email.address' -t rsa</code> 确认使用默认路径，然后输入两次你要是用的密码就行（一般直接敲几个回车不使用密码）。</p><h2>2、提交密匙</h2><p>现在又要回到github的页面上，在右上方工具栏里找到Account Settings。在这个页面上有一个SSH Public Keys标签，选择Add another public key。Title随便取，Key是一段东西。 找到刚才创建密匙的那个目录下（默认是C:\Documents and Settings\你的windows用户名.ssh，OSX是~/.ssh）找到id_rsa.pub文件，把它打开可以看到一堆文字，拷贝下来黏贴到github页面key的空白处。然后点击Apply确认。</p><h2>3、测试链接</h2><p><code>ssh -v git@github.com</code> 会要求输入你刚才设置的密码，如果成功的话可以看到类似下面的成功的提示信息。</p><pre><code class="language-shell">Hi wuhuanhost! You've successfully authenticated, but GitHub does not provide shell access.debug1: channel 0: free: client-session, nchannels 1Connection to github.com closed.Transferred: sent 3648, received 2064 bytes, in 0.6 secondsBytes per second: sent 5703.0, received 3226.7debug1: Exit status 1</code></pre><h2>4、创建一个新仓库</h2><p>先在github上创建并写好相关名字，描述。</p><pre><code>$ cd ~/thinkblog        //到thinkblog目录 $ git init                     //初始化$ git add .                   //把所有文件加入到索引（不想把所有文件加入，可以用gitignore或add 具体文件)$ git commit               //提交到本地仓库，然后会填写更新日志( -m “更新日志”也可)$ git remote add origin git@github.com:wuhuanhost/demo.git        //增加到remote$ git push origin master    //push到github上</code></pre><h2>5、更新项目</h2><h3>新加了文件</h3><pre><code>$ cd ~/demo$ git add .                  //这样可以自动判断新加了哪些文件，或者手动加入文件名字$ git commit              //提交到本地仓库$ git push origin master    //不是新创建的，不用再add 到remote上了</code></pre><h3>修改和删除文件</h3><pre><code>$ cd ~/demo $ git commit -a          //记录删除或修改了哪些文件$ git push origin master  //提交到github</code></pre><h2>6、忽略一些文件</h2><pre><code>$ cd ~/demo $ vim .gitignore     //把文件类型加入到.gitignore中，保存然后就可以git add . 能自动过滤这种文件</code></pre><h2>7、clone代码到本地</h2><pre><code>$ git clone git@github.com:wuhuanhost/demo.git </code></pre><h2>8、撤销</h2><pre><code>$ git reset</code></pre><h2>9、删除</h2><pre><code>$ git rm  * // 不是用rm </code></pre><h2>10、把代码更新到本地</h2><h3>方法一</h3><pre><code>$ git pull origin master </code></pre><h3>方法二 (推荐)</h3><pre><code>$ git fetch origin master            # 获取远程最新版本到本地$ git log -p master.. origin/master  # 查看远程分支和本地分支的差别$ git merge origin/master            # 合并远程分支到本地分支</code></pre><h3>方法三 (推荐)</h3><pre><code>$ git fetch origin master:tmp        # 获取远程分支到本地$ git diff tmp                       # 比较差异$ git merge tmp                      # 合并</code></pre><h2>11、文件恢复</h2><h3>恢复单个被删除的文件</h3><pre><code>$ git checkout [单个文件的名称]</code></pre><h3>恢复所有被删除的文件</h3><pre><code>$ git ls-files -d | xargs -i git checkout {}</code></pre><h2>12、提交到多个origin</h2><pre><code>$ git remote set-url --add origin git@github.com:wuhuanhost/demo.git</code></pre><blockquote><p>可以同时将本地仓库提交到多个远程仓库（例如，github、gitlab）</p></blockquote><h2>13、提交日志写错了修改方法</h2><pre><code>$ git commit --amend  </code></pre><h2>常见错误解决方法</h2><p>1、<code>$ git remote add origin git@github.com:wuhuanhost/demo.git</code> 错误提示：<code>fatal: remote origin already exists.</code> 解决办法：<code>$ git remote rm origin</code> 然后在执行：<code>$ git remote add origin git@github.com:wuhuanhost/demo.git</code> 就不会报错误了</p><p>2、<code>$ git push origin master</code> 错误提示：<code>error:failed to push som refs to</code> 解决办法：<code>$ git pull origin master</code> //先把远程服务器github上面的文件拉先来，再push 上去。 本人遇到的还有一个错误就是，工程传进github 了可是里头缺少文件， 解决方法 <code>$git add .</code> (注意一点）表示添加所有文件，</p><p>3、错误提示：** The authenticity of host 192.168.0.xxx can't be established.** 解决办法： <code>$ ssh -o StrictHostKeyChecking=no 192.168.0.xxx</code></p><h2>附录</h2><p><img src="git-command.png" alt="git命令大全，图片来源于网络"></p>]]></content>
    
    <summary type="html">
    
      git、github使用过程中记录的一些笔记，遇到的问题及其解决办法
    
    </summary>
    
      <category term="编程手册" scheme="https://www.wuhuan.me/categories/%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="git" scheme="https://www.wuhuan.me/tags/git/"/>
    
      <category term="开发工具" scheme="https://www.wuhuan.me/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>mongodb基础知识</title>
    <link href="https://www.wuhuan.me/2018/01/22/mongodb-001/"/>
    <id>https://www.wuhuan.me/2018/01/22/mongodb-001/</id>
    <published>2018-01-22T02:21:36.000Z</published>
    <updated>2018-10-31T00:48:38.976Z</updated>
    
    <content type="html"><![CDATA[<h3>MongoDB介绍</h3><p>MongoDB是一个基于分布式文件存储的开源文档数据库。由C++语言编写。旨在为WEB应用提供高性能、高可用性和高伸缩数据存储解决方案。</p><blockquote><p>MongoDB优点</p></blockquote><p><img src="/mongodb%E4%BC%98%E7%82%B9-2018123.png" alt="MongoDB优点"></p><h3>MongoDB使用场景</h3><ul><li><p>数据缓存</p><p>由于性能很高，MongoDB适合作为信息基础设施的缓存层。在系统重启之后，由MongoDB搭建的持久化缓存层可以避免下层的数据源过载。</p></li><li><p>对象和json存储</p><p>MongoDB的BSON(二进制JSON)数据格式非常适合文档化格式的存储及查询,而且JSON格式存储最接近真实对象模型，对开发者友好，方便快速开发迭代,灵活的模式让你不在为了不断变化的需求而去频繁修改数据库字段和结构。</p></li><li><p>高伸缩性场景</p><p>MongoDB通过分片集群，使MongoDB服务能力易于水平扩展。</p></li><li><p>弱事务类型业务</p><p>MongoDB不支持多文档事务，所以像银行系统这种需要大量原子性复杂事务的程序不适合使用MongoDB。<strong>（注：MongoDB 4.0将支持跨文档的事务）</strong>。</p></li></ul><p><img src="/mongodb%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D.png" alt="mongodb版本特性介绍"></p><h3>MongoDB概念</h3><blockquote><p>通过和关系型数据库mysql的对照，让我们更容易的理解MongoDB的一些概念</p></blockquote><table><thead><tr><th>关系型数据库（sql）概念</th><th>MongoDB概念</th><th>说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据行/文档</td></tr><tr><td>column</td><td>filed</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr></tbody></table><p><img src="/mongodb%E6%95%B0%E6%8D%AE%E5%85%B3%E7%B3%BB%E5%9B%BE-2018123.png" alt="MongoDB数据关系图"></p><h4>数据库</h4><ul><li><p>一个MongoDB中可以建立多个数据库。</p></li><li><p>MongoDB的默认数据库为&quot;db&quot;，该数据库存储在data目录中</p></li></ul><h4>集合</h4><ul><li><p>集合名不能以&quot;system.&quot;开头</p></li><li><p>关系型数据库中的表（table）中的每一条数据（row）的格式是事先约定好的的，而MongoDB中的集合（collection）中文档（document）的数据格式是不固定的，也就是说我们可以将如下数据插入统一文档中。</p></li></ul><pre><code class="language-json">{&quot;site&quot;:&quot;www.wuhuan.me&quot;}{&quot;site&quot;:&quot;www.baidu.com&quot;,&quot;name&quot;:&quot;百度&quot;}</code></pre><h4>文档</h4><ul><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)</li></ul><p><em><em>例如：在关系型数据库中有一张</em>students</em>表和<strong>course</strong>表，表的结构和数据如下:**</p><p><strong>students表</strong></p><table><thead><tr><th>id</th><th>name</th><th>sex</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>李雷</td><td>0</td><td>12</td></tr><tr><td>2</td><td>韩梅梅</td><td>1</td><td>12</td></tr></tbody></table><p><strong>course表</strong></p><table><thead><tr><th>id</th><th>course_id</th><th>course_name</th><th>score</th><th>user_id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>语文</td><td>99</td><td>1</td></tr><tr><td>2</td><td>2</td><td>数学</td><td>100</td><td>1</td></tr><tr><td>3</td><td>1</td><td>语文</td><td>96</td><td>2</td></tr><tr><td>4</td><td>2</td><td>数学</td><td>98</td><td>3</td></tr></tbody></table><p><strong>以上数据和结构在MongoDB中可以使用内嵌文档来表示（一对多）的关系:</strong></p><pre><code class="language-json">{  &quot;_id&quot;:ObjectId(&quot;5349b4ddd2781d08c09890f3&quot;),  &quot;name&quot;:&quot;李雷&quot;,  &quot;sex&quot;:&quot;0&quot;,  &quot;age&quot;:&quot;12&quot;,  &quot;course&quot;:[{    &quot;course_id&quot;:1,    &quot;course_name&quot;:&quot;语文&quot;,    &quot;score&quot;:99,  },{    &quot;course_id&quot;:2,    &quot;course_name&quot;:&quot;数学&quot;,    &quot;score&quot;:100,  }]}{  &quot;_id&quot;:ObjectId(&quot;5349b4ddd2781d08c09890f4&quot;),  &quot;name&quot;:&quot;韩梅梅&quot;,  &quot;sex&quot;:&quot;1&quot;,  &quot;age&quot;:&quot;12&quot;,  &quot;course&quot;:[{    &quot;course_id&quot;:1,    &quot;course_name&quot;:&quot;语文&quot;,    &quot;score&quot;:96,  },{    &quot;course_id&quot;:2,    &quot;course_name&quot;:&quot;数学&quot;,    &quot;score&quot;:98,  }]}</code></pre><ul><li>文档中的键/值对是有序的，文档中的键是不能重复，且区分大小写。</li></ul><h4>数据类型</h4><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>String</td><td>字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td></tr><tr><td>Integer</td><td>整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td></tr><tr><td>Boolean</td><td>布尔值。用于存储布尔值（真/假）。</td></tr><tr><td>Double</td><td>双精度浮点值。用于存储浮点值。</td></tr><tr><td>Min/Max</td><td>keys将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td></tr><tr><td>Array</td><td>用于将数组或列表或多个值存储为一个键。</td></tr><tr><td>Timestamp</td><td>时间戳。记录文档修改或添加的具体时间。</td></tr><tr><td>Object</td><td>用于内嵌文档。</td></tr><tr><td>Null</td><td>用于创建空值。</td></tr><tr><td>Symbol</td><td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td></tr><tr><td>Date</td><td>日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td></tr><tr><td>Object ID</td><td>对象 ID。用于创建文档的 ID。</td></tr><tr><td>Binary Data</td><td>二进制数据。用于存储二进制数据。</td></tr><tr><td>Code</td><td>代码类型。用于在文档中存储 JavaScript 代码。</td></tr><tr><td>Regular expression</td><td>正则表达式类型。用于存储正则表达式。</td></tr></tbody></table><h4>ObjectId</h4><p>MongoDB文档必须有一个默认的**_id<strong>键,且在一个集合里</strong>_id<strong>始终唯一。</strong>_id**键的值可以是任何类型的，默认是个ObjectId对象，它由MongoDB数据库自动创建。MongoDB使用objectId而不是使用常规做法（自增主键）主要原因是,在多个服务器（分布式）同步自动增加主键费力费时。</p><p><strong>ObjectId</strong>由12个字节的<a href="https://baike.baidu.com/item/BSON/10981745?fr=aladdin" rel="external nofollow noopener noreferrer" target="_blank">BSON</a>组成</p><ul><li><p>前4个字节表示时间戳</p></li><li><p>接下来的3个字节是机器标识码</p></li><li><p>紧接的两个字节由进程id组成（PID）</p></li><li><p>最后三个字节是随机数。</p></li></ul><p><strong>创建新的ObjectId</strong></p><p>我们可以在命令行通过如下语句来创建一个新的ObjectId</p><pre><code class="language-shell">&gt; newId=ObjectId()</code></pre><p>上面语句将返回一个唯一的_id</p><pre><code class="language-json">ObjectId(&quot;1249b4ddd2712d08c09890f3&quot;)</code></pre><p>也可以使用生成的ObjectId替换MongoDB自动生成的ObjectId。</p><h3>MongoDB基本使用</h3><h4>安装数据库</h4><p>在windows安装MongoDB比较简单在官网<a href="https://www.mongodb.com/download-center?jmp=nav#enterprise" rel="external nofollow noopener noreferrer" target="_blank">MongoDB下载地址</a>下载对应的windows安装包一键安装就行了。</p><p>安装完之后记得将<code>MongoDB</code>安装目录下的<code>bin</code>目录加入到系统的环境变量中。</p><h4>启动数据库</h4><p><strong>启动数据库使用<code>mongod</code>命令</strong></p><ul><li>方式一：普通方式启动</li></ul><pre><code class="language-shell">&gt; mongod --dbpath  E:\MongoDB\data\db  #不使用默认端口的话可以加上--port=[端口号]参数</code></pre><blockquote><p><strong>E:\data\db</strong>为数据文件路径</p></blockquote><ul><li>方式二：通过配置文件启动</li></ul><pre><code class="language-shell">&gt; mongod --config E:\MongoDB\mongo.conf</code></pre><blockquote><p><strong>E:\MongoDB\mongo.conf</strong>为配置文件路径，配置文件内容为:</p></blockquote><pre><code># 服务端口port=27017# 数据文件路径dbpath=E:\mongondb\data\db # 日志文件路径logpath=E:\mongondb\log\mongon.log# 打开日志输出操作logappend=true# 不使用任何的验证方式登录noauth=true</code></pre><h4>连接数据库</h4><p>**连接数据库使用<code>mongo [,链接字符串]</code>**连接url的标准语法如下</p><pre><code class="language-shell">mongodb://[username:password@]host[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]</code></pre><ul><li>登录本地默认数据库服务器，无用户名密码，端口默认<strong>27017</strong>,链接默认的<strong>db</strong>数据库</li></ul><pre><code class="language-shell">&gt; mongo mongodb://localhost/db </code></pre><p>或者</p><pre><code class="language-shell">&gt; mongo </code></pre><ul><li>使用用户名admin、密码123456，登录本地端口为27017的test数据库。</li></ul><pre><code class="language-shell">&gt; mongo mongodb://admin:123456@localhost:27017/test</code></pre><h4>创建数据库</h4><p>创建数据库使用<code>use [数据库名]</code>,例如创建一个<strong>test123</strong>的数据库</p><pre><code class="language-shell">&gt; use test123switched to db test123&gt; dbtest123</code></pre><p>显示当前所有的数据库可以使用命令<code>show dbs</code></p><pre><code class="language-shell">&gt; show dbsdb     0.001GBlocal  0.000GB</code></pre><p>怎么没有我们刚才创建的<code>test123</code>呢?那是因为数据库中还没有内容，我们向<code>test123</code>中插入<code>db.[集合名称].insert(json格式的数据对象)</code>一条数据，再看看！</p><pre><code class="language-shell">&gt; show dbsdb     0.001GBlocal  0.000GB&gt; use test123switched to db test123&gt; dbtest123&gt; db.coll.insert({&quot;title&quot;:&quot;not data!&quot;})WriteResult({ &quot;nInserted&quot; : 1 })&gt; show dbsdb       0.001GBlocal    0.000GBtest123  0.000GB</code></pre><p>查看<code>db.[集合名称].find()</code>刚才添加的数据</p><pre><code class="language-shell">&gt; use test123switched to db test123&gt; db.coll.find(){ &quot;_id&quot; : ObjectId(&quot;5a66e39914fea5f8ff237420&quot;), &quot;title&quot; : &quot;not data!&quot; }</code></pre><p><strong><em>使用use命令如果数据库不存在则创建，存在则切换到指定的数据库。</em></strong></p><h4>删除数据库</h4><p>删除数据库使用<code>db.dropDatabase()</code>函数进行</p><p>首先查看所有的数据库</p><pre><code class="language-shell">&gt; show dbsdb       0.001GBlocal    0.000GBtest123  0.000GB</code></pre><p>接着切换到要删除的数据库<strong>test123</strong></p><pre><code class="language-shell">&gt; use test123switched to db test123</code></pre><p>删除当前数据库</p><pre><code class="language-shell">&gt; db.dropDatabase(){ &quot;dropped&quot; : &quot;test123&quot;, &quot;ok&quot; : 1 }  #删除成功</code></pre><h4>数据增加</h4><p><strong>数据添加方法：insert(),insertOne(),insertMany()</strong></p><p><strong>添加一条数据</strong></p><pre><code class="language-shell">/** insert()方法 **/&gt; db.person.insert({name:&quot;张三&quot;,age:18,sex:&quot;男&quot;});WriteResult({ &quot;nInserted&quot; : 1 })&gt; db.person.find()                             });{ &quot;_id&quot; : ObjectId(&quot;5a7941c65f6d5986321c8416&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;男&quot; }/** insertOne()方法插入一条数据 **/&gt; db.person.insertOne({name:&quot;张三&quot;,age:18,sex:&quot;男&quot;});{                                               dered:true})        &quot;acknowledged&quot; : true,        &quot;insertedId&quot; : ObjectId(&quot;5a7965855f6d5986321c8422&quot;)}&gt; db.person.find(){ &quot;_id&quot; : ObjectId(&quot;5a7965855f6d5986321c8422&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;男&quot; }&gt;</code></pre><p><strong>添加多条数据</strong></p><p>*** 方式一 把要插入的数据放在一个数组中进行批量插入***</p><pre><code class="language-shell">/** insert()方法 **/&gt; db.person.insert( [ {name:&quot;张三&quot;,age:18,sex:&quot;男&quot;}, {name:&quot;李四&quot;,age:21,sex:&quot;女&quot;}, {name:&quot;王五&quot;,age:20,sex:&quot;男&quot;}, {name:&quot;赵六&quot;,age:19,sex:&quot;女&quot;} ],{ordered:true})BulkWriteResult({        &quot;writeErrors&quot; : [ ],        &quot;writeConcernErrors&quot; : [ ],        &quot;nInserted&quot; : 4,        &quot;nUpserted&quot; : 0,        &quot;nMatched&quot; : 0,        &quot;nModified&quot; : 0,        &quot;nRemoved&quot; : 0,        &quot;upserted&quot; : [ ]})/** insertMany()方法 **/&gt; db.person.insertMany( [ {name:&quot;张三&quot;,age:18,sex:&quot;男&quot;}, {name:&quot;李四&quot;,age:21,sex:&quot;女&quot;}, {name:&quot;王五&quot;,age:20,sex:&quot;男&quot;}, {name:&quot;赵六&quot;,age:19,sex:&quot;女&quot;} ],{ordered:true}){        &quot;acknowledged&quot; : true,        &quot;insertedIds&quot; : [                ObjectId(&quot;5a7969ec5f6d5986321c8430&quot;),                ObjectId(&quot;5a7969ec5f6d5986321c8431&quot;),                ObjectId(&quot;5a7969ec5f6d5986321c8432&quot;),                ObjectId(&quot;5a7969ec5f6d5986321c8433&quot;)        ]}</code></pre><p>多加了一个参数{ordered:true}表示有序插入， 有序插入碰到异常时它会直接返回，不会继续插入数组中其余的文档记录。不加此参数或者{ordered:false}为无序插入， 无序的插入会在遇到异常时继续执行</p><p>*** 方式二 使用bluk对象进行数据的批量添加 ***</p><ul><li>第一步：初始化一个批量操作对象</li></ul><pre><code class="language-javascript">var bulk = db.person.initializeUnorderedBulkOp();</code></pre><ul><li>第二步：把要添加的数据添加到bulk对象中</li></ul><pre><code class="language-javascript">bulk.insert({name:&quot;赵六&quot;,age:19,sex:&quot;女&quot;});bulk.insert({name:&quot;赵六&quot;,age:19,sex:&quot;女&quot;});bulk.insert({name:&quot;赵六&quot;,age:19,sex:&quot;女&quot;});</code></pre><ul><li>第三步：真正添加到数据库的方法</li></ul><pre><code class="language-javascript">bulk.execute();</code></pre><blockquote><p>插入文档你也可以使用 db.集合名称.save(document) 命令。如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。</p></blockquote><blockquote><p>insert()方法既可以插入一个数组也可插入一个对象，insertOne()方法只能插如一个对象，insertMany()只能插入一个数组，insert()返回插入成功的记录条数，而insertOne()和insertMany()方法返回成功标志和插入成功的_objectId</p></blockquote><h4>数据查询</h4><p><strong>查询命令：find()，findOne()</strong></p><p><strong><em><code>findOne()</code>方法查询的结果已经格式化输出了，<code>find()</code>方法要想格式化输出数据调用<code>pertty()</code>修饰查询方法也能达到相同的效果。</em></strong></p><p>举例：<code>db.person.find({age:18})</code> <strong><em>查询年龄等于18的人的所有信息</em></strong></p><p>举例：<code>db.person.find({age:{$gt:18}},{name:1,sex:1})</code> <strong><em>查询db数据库中person集合中年龄大于18的人的姓名和性别</em></strong></p><blockquote><p>说明：如果年龄小于18可以使用$lt操作符，第二个参数{name:1,sex:1}里面表示显示的字段，如果不想显示某个字段那么就不用写如果第二个参数是{name:1}，那么表示只显示姓名字段，如果整个第二个参数都不写，那么默认显示所有的字段</p></blockquote><p>修饰查询的方法：<code>limit()</code>【限制条数】,<code>sort()</code>【排序】,<code>skip()</code>【跳过】,<code>pretty()</code>【美化格式】</p><p>举例：<code>db.person.find({age:{$gt:18}},{name:1,sex:1,age:1}).sort({age:-1}).limit(3).skip(1).pretty()</code> <strong><em>查询db数据库中person集合中年龄大于18的人的姓名和性别,然后按照年龄降序排列，然后取排列后的数据的前三条，然后再跳过一条数据后的集合</em></strong></p><blockquote><p>说明：sort({age:-1})中的【-1】表示降序排列，如果升序排列写成sort({age:1})就可以。</p></blockquote><h4>数据删除</h4><p><strong>删除方法：remove()，drop()</strong></p><p><strong>1、remove()和drop()方法的区别</strong></p><p>举例：<code>db.person.remove({})</code> <strong><em>remove方法中传递一个空数对象，会删掉db数据库中的person集合中的所有的文档，但是不会删除索引</em></strong></p><p>举例：<code>db.person.drop()</code> <strong><em>会删除db数据库中的person集合中的所有的文档，并且还会删除person集合中所有的索引。效率更高。</em></strong></p><p><strong>2、删除匹配条件的文档</strong></p><p>举例：<code>db.person.remove({name:&quot;张三&quot;})</code> <strong><em>删除db数据库中person集合中name等于张三的所有文档。</em></strong></p><p><strong>3、删除一条记录</strong></p><p>举例： 方法1 <code>db.person.remove({name:&quot;张三&quot;},{justOne:true});</code> 方法2 <code>db.person.remove({name:&quot;张三&quot;},1);</code></p><blockquote><p>只删除一个匹配条件的文档</p></blockquote><h4>数据修改</h4><p><strong>修改方法：update()</strong></p><p>1、<code>$set</code>操作符 举例：<code>db.person.update({name:&quot;张三&quot;},{$set:{age:19}})</code> <strong><em>修改名字为张三的人的年龄为19岁，只修改一条记录</em></strong></p><p>2、<code>$currentDate</code>操作符的作用 举例：<code>db.person.update({name:&quot;张三&quot;},{ $set:{age:&quot;123456&quot;},$currentDate: { lastModified: true }})</code> <strong><em>为当前修改的文档添加一个最后修改时间的字段</em></strong></p><p>3、<code>{multi:true}</code>参数的作用 举例：<code>db.person.update({name:&quot;张三&quot;},{$set:{age:20},$currentDate: { lastModified: true }},{multi:true})</code> <strong><em>默认情况下只修改符合条件的一个文档，如果多个文档符合条件并且都要修改只需要添加第三个参数{multi:true}就可以修改多个文档了。</em></strong></p><p>4、<code>upsert</code>选项的作用 举例：<code>db.person.update({name:&quot;张三&quot;},{name:'张三三',age:20,sex:&quot;男&quot;},{upsert:true})</code> <strong><em>默认情况下匹配不到更新条件的文档，update将不做任何操作，如果添加了{upsert:true}参数，在没有找到匹配文档的情况下，它将会插入一个新的文档。</em></strong></p><blockquote><p>注意：mongondb在修改数据的时候回根据数据的类型自动修改文档中原始的数据类型，例如一个文档中的年龄为数字类型，你修改这个记录的时候把年龄传入一个字符串，那么此文档中年龄字段的类型就变成了字符串类型。</p></blockquote><h4>索引</h4><p>索引通常能够极大的提高查询的效率，就像书的目录一样，如果没有索引mongodb就会去扫描集合中的每个文件并选取符合查询条件的数据,在数据量大的时候这种查询相率很低下</p><p>使用<code>db.集合名称.getIndexes()</code>获取集合索引</p><pre><code class="language-shell">&gt; db.person.getIndexes()[        {  //person集合的默认索引                &quot;v&quot; : 1, //升序排列                &quot;key&quot; : {                        &quot;_id&quot; : 1 //索引列                },                &quot;name&quot; : &quot;_id_&quot;, //索引名称                &quot;ns&quot; : &quot;test.person&quot; //指定集合        }]</code></pre><p><strong>创建索引</strong></p><p>创建索引的方法：<code>createIndex()</code></p><p>举例：<code>db.person.createIndex({&quot;name&quot;:1})</code> <strong><em>在person集合中针对name字段创建一个升序排列的索引</em></strong></p><pre><code class="language-shell">&gt; db.person.getIndexes()[        { // 默认索引                &quot;v&quot; : 1,                &quot;key&quot; : {                        &quot;_id&quot; : 1                },                &quot;name&quot; : &quot;_id_&quot;,                &quot;ns&quot; : &quot;test.person&quot;        },        { //新创建的索引                &quot;v&quot; : 1,                &quot;key&quot; : {                        &quot;name&quot; : 1                },                &quot;name&quot; : &quot;name_1&quot;,                &quot;ns&quot; : &quot;test.person&quot;        }]</code></pre><p><strong>删除索引</strong></p><p>删除索引使用命令：<code>dropIndex()</code> 举例：db.person.dropIndexes({&quot;name&quot;:1})</p><pre><code class="language-shell">&gt; db.person.getIndexes() //查询索引[        {                &quot;v&quot; : 1,                &quot;key&quot; : {                        &quot;_id&quot; : 1                },                &quot;name&quot; : &quot;_id_&quot;,                &quot;ns&quot; : &quot;test.person&quot;        },        {                &quot;v&quot; : 1,                &quot;key&quot; : {                        &quot;name&quot; : 1                },                &quot;name&quot; : &quot;name_1&quot;,                &quot;ns&quot; : &quot;test.person&quot;        }]&gt; db.person.dropIndex({&quot;name&quot;:1})  //删除{ &quot;nIndexesWas&quot; : 2, &quot;ok&quot; : 1 }&gt; db.person.getIndexes() //查询索引[        {                &quot;v&quot; : 1,                &quot;key&quot; : {                        &quot;_id&quot; : 1                },                &quot;name&quot; : &quot;_id_&quot;,                &quot;ns&quot; : &quot;test.person&quot;        }]</code></pre><p>删除全部索引使用命令：<code>dropIndexes()</code> 举例：db.person.dropIndexes()</p><pre><code class="language-shell">&gt; db.person.getIndexes() //查询索引[        {                &quot;v&quot; : 1,                &quot;key&quot; : {                        &quot;_id&quot; : 1                },                &quot;name&quot; : &quot;_id_&quot;,                &quot;ns&quot; : &quot;test.person&quot;        },        {                &quot;v&quot; : 1,                &quot;key&quot; : {                        &quot;name&quot; : 1                },                &quot;name&quot; : &quot;name_1&quot;,                &quot;ns&quot; : &quot;test.person&quot;        }]&gt; db.person.dropIndexes() //删除全部索引{        &quot;nIndexesWas&quot; : 2,        &quot;msg&quot; : &quot;non-_id indexes dropped for collection&quot;,        &quot;ok&quot; : 1}&gt; db.person.getIndexes() //查询索引[        {                &quot;v&quot; : 1,                &quot;key&quot; : {                        &quot;_id&quot; : 1                },                &quot;name&quot; : &quot;_id_&quot;,                &quot;ns&quot; : &quot;test.person&quot;        }]</code></pre><p><strong><em>删除全部索引指的是：name为非_id_的索引（默认索引）</em></strong></p><h4>导出数据文件</h4><pre><code class="language-shell">mongodump -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -o 文件存在路径 </code></pre><ul><li>如果没有用户谁，可以去掉-u和-p。</li><li>如果导出本机的数据库，可以去掉-h。</li><li>如果是默认端口，可以去掉--port。</li><li>如果想导出所有数据库，可以去掉-d。</li></ul><p><strong>导出全部数据数据库</strong></p><pre><code>mongodump -h 127.0.0.1 -o E:\mongondb\dump </code></pre><h4>导入数据文件</h4><pre><code class="language-shell">&gt; mongorestore -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 --drop 文件存在路径 </code></pre><blockquote><p>--drop的意思是，先删除所有的记录，然后恢复。</p></blockquote><p><strong>导入全部数据库</strong></p><pre><code class="language-shell">&gt; mongorestore E:\mongondb\dump </code></pre><p><strong>导入test123数据库</strong></p><pre><code class="language-shell">&gt; mongorestore -d user E:\mongondb\dump\test123  #test123这个数据库的备份路径  </code></pre>]]></content>
    
    <summary type="html">
    
      mongodb基础知识，mongodb学习笔记
    
    </summary>
    
      <category term="后端开发" scheme="https://www.wuhuan.me/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="数据库" scheme="https://www.wuhuan.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mongodb" scheme="https://www.wuhuan.me/tags/mongodb/"/>
    
      <category term="nosql" scheme="https://www.wuhuan.me/tags/nosql/"/>
    
  </entry>
  
  <entry>
    <title>Node接收电子邮件</title>
    <link href="https://www.wuhuan.me/2017/07/20/node-receive-mail/"/>
    <id>https://www.wuhuan.me/2017/07/20/node-receive-mail/</id>
    <published>2017-07-20T02:21:36.000Z</published>
    <updated>2018-10-31T00:48:38.986Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章写了如何通过node发送电子邮件，有发送就会有接收嘛，所以这篇文章来说说关于在node中如何接收电子邮件。</p><h2>邮件协议</h2><p>在开始这篇文章之前我们首先了解三个协议smtp（Simple Mail Transfer Protocol）简单邮件传输协议，pop3（Post Office Protocol 3）邮局协议第三版本，imap（Internet Mail Access Protocol）internet消息访问协议。</p><h3>smtp协议</h3><p>简单邮件传输协议：是一种基于文本的电子邮件传输协议，用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式，是因特网中用于在邮件服务器之间交换邮件的协议。SMTP是一个“推”的协议，它不允许根据需要从远程服务器上“拉”来消息。要做到这点，邮件客户端必须使用POP3或IMAP。所以发送邮件的时候我们需要简单的了解下面的这两种协议。</p><h3>pop3协议</h3><p>POP3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、删除邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的。也就是说POP3协议实际上是下载了一份邮件的副本到本地邮件客户端，而且对本地邮件副本的操作只会影响本地数据。多个邮件客户端里面的邮件的状态可能会不一致。</p><h3>imap协议</h3><p>IMAP（Internet消息访问协议）也是提供面向用户的邮件收取服务。常用的版本是IMAP4。与POP3协议类似允许电子邮件客户端下载服务器上的邮件，不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。换句话说，IMAP把远程文件夹当成本地文件夹来操作，它们之间类似于双向同步。这样的好处是，当你在多个邮件客户端看见的邮件的状态是一致的。本次接收邮件我们也使用此协议来实现。</p><h2>接收邮件测试过程</h2><p>接收邮件实际上做的是一个邮件客户端的东西，对于底层的实现在npm上有一个写好的第三的库node-imap（node.js的imap客户端模块）这个模块帮助我们封装了很多的底层操作，但是这个模块返回的数据像附件、消息、邮件头等都是未解码的原始数据，所以还需要对数据进行解码，解码的模块在npm上也找到了一个写好的库Mailparser它是一个node高级电子邮件解析器，能够解析即使非常大的数据（100MB+）,而且开销相对比较低。</p><p>使用imap接收邮件的过程可以用下面一张图表示</p><p><img src="/receive-mail/post_receive_mail.jpg" alt="imap接收邮件测试过程"></p><p><strong>本次测试的大概过程如下</strong></p><ul><li>在pc上登录qq邮箱</li><li>通过qq邮箱发邮件到gamil（不同邮件服务器之间发邮件过程比较复杂，过程略）</li><li>在pc上通过写好的基于imap的程序去拉取gmail的邮件，同时本地的修改（标记邮件，删除邮件）会同步到gmail服务器</li></ul><h3>安装node第三方包</h3><pre><code>npm install --save imap mailparser</code></pre><blockquote><p>邮件接收服务器我选择Gmail,发送邮件的服务器使用qq邮箱。</p></blockquote><h3>使用qq邮箱发送一封带有附件的邮件</h3><p><img src="/receive-mail/post_mail.png" alt="发送一封带附件的电子邮件"></p><h3>通过程序接收邮件</h3><p><img src="/receive-mail/receive_mail.png" alt="node接收到的电子邮件信息"></p><h3>查看附件保存时否正确</h3><p><img src="/receive-mail/attachment.png" alt="查看附件是否保存成功"></p><h2>核心代码</h2><pre><code>var Imap = require('imap')var MailParser = require(&quot;mailparser&quot;).MailParservar fs = require(&quot;fs&quot;)var imap = new Imap({    user: 'yourname@gmail.com', //你的邮箱账号    password: 'yourpassword', //你的邮箱密码    host: 'imap.gmail.com', //邮箱服务器的主机地址    port: 993, //邮箱服务器的端口地址    tls: true, //使用安全传输协议    tlsOptions: { rejectUnauthorized: false } //禁用对证书有效性的检查});function openInbox(cb) {    imap.openBox('INBOX', true, cb);}imap.once('ready', function() {    openInbox(function(err, box) {        console.log(&quot;打开邮箱&quot;)        if (err) throw err;        imap.search(['UNSEEN', ['SINCE', 'May 20, 2017']], function(err, results) {//搜寻2017-05-20以后未读的邮件            if (err) throw err;            var f = imap.fetch(results, { bodies: '' });//抓取邮件（默认情况下邮件服务器的邮件是未读状态）            f.on('message', function(msg, seqno) {                var mailparser = new MailParser();                msg.on('body', function(stream, info) {                    stream.pipe(mailparser);//将为解析的数据流pipe到mailparser                    //邮件头内容                    mailparser.on(&quot;headers&quot;, function(headers) {console.log(&quot;邮件头信息&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);                        console.log(&quot;邮件主题: &quot; + headers.get('subject'));                        console.log(&quot;发件人: &quot; + headers.get('from').text);                        console.log(&quot;收件人: &quot; + headers.get('to').text);                    });                    //邮件内容                    mailparser.on(&quot;data&quot;, function(data) {                        if (data.type === 'text') {//邮件正文console.log(&quot;邮件内容信息&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);                            console.log(&quot;邮件内容: &quot; + data.html);                        }                        if (data.type === 'attachment') {//附件console.log(&quot;邮件附件信息&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);                            console.log(&quot;附件名称:&quot;+data.filename);//打印附件的名称                            data.content.pipe(fs.createWriteStream(data.filename));//保存附件到当前目录下                            data.release();                        }                    });                });                msg.once('end', function() {                    console.log(seqno + '完成');                });            });            f.once('error', function(err) {                console.log('抓取出现错误: ' + err);            });            f.once('end', function() {                console.log('所有邮件抓取完成!');                imap.end();            });        });    });});imap.once('error', function(err) {    console.log(err);});imap.once('end', function() {    console.log('关闭邮箱');});imap.connect();</code></pre><p><strong>默认情况下抓取邮件后邮件服务器的邮件状态为未读，如果要在抓取后让邮箱服务器中的邮件状态变为已读，可以修改</strong></p><pre><code>var f = imap.fetch(results, { bodies: '' });</code></pre><p><strong><em>为</em></strong></p><pre><code>var f = imap.fetch(results, { bodies: '', markSeen: true }); </code></pre><h2>参考文档</h2><p><a href="https://github.com/mscdex/node-imap" rel="external nofollow noopener noreferrer" target="_blank">查看node-imap详细文档和api请点击这里</a> <a href="https://nodemailer.com/extras/mailparser/" rel="external nofollow noopener noreferrer" target="_blank">查看Mailparser详细文档请点击这里</a></p><h2>后记</h2><p>如果google邮箱如果开启了二次认证，那么你需要在google后台生成一个专用密码来登录google邮箱拉取邮件。</p><p>通过一个简单的例子实现了如何使用node和imap协议来接收邮件，结合上篇<a href="http://www.mengxiangjia.info/2017/06/20/node-post-mail/" rel="external nofollow noopener noreferrer" target="_blank">node发送电子邮件</a>文章的内容，一个简单的邮件客户端的基本收信发信功能就有了，但是想实现一个功能完善用户体验好的邮件客户端就需要不断揣摩它，设计它，完善它，希望这篇文章能带给你启发，可以实现一个属于你自己的邮件客户端。</p>]]></content>
    
    <summary type="html">
    
      Node接收电子邮件
    
    </summary>
    
      <category term="后端开发" scheme="https://www.wuhuan.me/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="电子邮件" scheme="https://www.wuhuan.me/tags/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/"/>
    
      <category term="node.js" scheme="https://www.wuhuan.me/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>Node发送电子邮件</title>
    <link href="https://www.wuhuan.me/2017/06/20/node-post-mail/"/>
    <id>https://www.wuhuan.me/2017/06/20/node-post-mail/</id>
    <published>2017-06-20T02:21:36.000Z</published>
    <updated>2018-10-31T00:48:38.985Z</updated>
    
    <content type="html"><![CDATA[<p>电子邮件作为最广泛使用的一种网络服务和我们的工作学习生活已经密不可分。接受信用卡的账单，注册网站，找回密码等等都需要用到它。今天在就来学习下如何在node下来发送邮件，为当前做的项目提供邮箱校验的功能。</p><p>邮箱校验的原理：当我们在xxx网站注册的时候，注册信息中一般都会要求你填一个邮箱（作用：1、当着登录的用户账号，2、找回密码），当你注册成功后系统就会向你填写的邮箱中发送一封带有特殊链接的邮件，要求你打开你的邮件去点击，当你进入邮箱点击连接系统就会接受到一个get请求从而验证邮箱是你本人的。</p><p>node发送邮件已经有一些第三方的组件，这里我使用nodemailer这个带三方组件来发邮件，如果不使用封装好的第三方组件自己写的话需要去熟悉和研究复杂的邮件协议来实现，如果要开发一个邮件服务那么这是必要的，但是一个小小的邮件验证我觉得这是非必要的。</p><h2>创建本次邮箱校验demo使用的数据库的表</h2><pre><code class="language-sql">DROP TABLE IF EXISTS `user_info`;CREATE TABLE `user_info` (  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',  `username` varchar(20) NOT NULL COMMENT '用户名',  `password` varchar(255) NOT NULL COMMENT '用户密码',  `email` varchar(255) NOT NULL COMMENT '邮箱',  `code` varchar(255) NOT NULL COMMENT '邮箱验证使用的code',  `email_state` int(2) NOT NULL COMMENT '邮箱验证状态。 0:未验证，1:已验证',  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><p>这就是本次邮箱校验demo中用到的用户信息表，其实还应该有一张表存放每次发送邮箱验证时候生成的一些数据，比如code，过期时间等，在这里我就不校验邮件的过期时间了，code也直接放在用户信息表中了，如果你在正式系统中请新建一张表或者在缓存中来存放每次发送邮件生成的临时数据。</p><h2>nodemailder介绍及其使用</h2><h3>特性列表</h3><ul><li>不依赖于其它模块</li><li>支持unicode编码，包括emoji表情</li><li>支持windows系统</li><li>邮件内容支持纯文本和html</li><li>支持添加附件</li><li>邮件内容如果是html还可以插入图片</li><li>支持除了默认SMTP协议外的其它传输协议</li><li>使用TLS / STARTTLS安全电子邮件传递</li><li>SMTP连接代理</li><li>健全的oauth2认证</li><li>DKIM消息签名</li><li>自定义插件支持处理消息</li><li>支持es6语法</li></ul><p>详细文档<a href="https://nodemailer.com" rel="external nofollow noopener noreferrer" target="_blank">nodemailer官方地址</a></p><h3>nodemailer配置</h3><p>通过<code>npm install nodemailer --save</code>安装这个模块到项目。当前的nodemailer的版本是<code>4.0.1</code></p><h3>nodemailer使用</h3><p>使用nodemailer发送一封邮件大概需要4步</p><h4>1、在文件中引入nodemailer</h4><pre><code>const nodemailer = require('nodemailer');</code></pre><h4>2、创建一个传输对象</h4><pre><code>let transporter = nodemailer.createTransport({    host: 'smtp.163.com',    port: 465,    secure: true,    auth: {user: 'username@163.com', //邮箱的账号pass: 'userpass'//邮箱的密码    }});</code></pre><h4>3、设置电子邮件</h4><pre><code>let mailOptions = {    from: '&quot;Fred Foo 👻&quot; &lt;username@163.com&gt;', //邮件来源    to: 'username@qq.com', //邮件发送到哪里，多个邮箱使用逗号隔开    subject: 'Hello ✔', // 邮件主题    text: 'Hello world ?', // 存文本类型的邮件正文    html: '&lt;b&gt;Hello world ?&lt;/b&gt;' // html类型的邮件正文};</code></pre><h4>4、使用第二步定义的传输对象发送邮件</h4><pre><code>transporter.sendMail(mailOptions, (error, info) =&gt; {    if (error) {return console.log(error);    }    console.log('Message %s sent: %s', info.messageId, info.response);});</code></pre><h3>发送带有附件的邮件</h3><pre><code>let mailOptions = {    from: '&quot;Fred Foo 👻&quot; &lt;username@163.com&gt;', //邮件来源    to: 'username@qq.com', //邮件发送到哪里，多个邮箱使用逗号隔开    subject: 'Hello ✔', // 邮件主题    html: '&lt;b&gt;Hello world ?&lt;/b&gt;', // html类型的邮件正文    attachments: [ //附件数组{    filename: 'text.txt',//附件名称    path: './text.txt'//附件的位置}    ]};</code></pre><h3>发送正文中带有图片的邮件</h3><blockquote><p>设置邮件的正文的类型为html类型,图片还是按照附件的方式发送，只不过比发送附件多了一个cid，然后将正文图片的src值指向attachments对象中的cid的值就可以了。</p></blockquote><pre><code>let mailOptions = {    from: '&quot;Fred Foo 👻&quot; &lt;username@163.com&gt;', //邮件来源    to: 'username@qq.com', //邮件发送到哪里，多个邮箱使用逗号隔开    subject: 'Hello ✔', // 邮件主题    html: '&lt;b&gt;Hello world ?&lt;img src=&quot;cid:123456789&quot;/&gt;&lt;/b&gt;', // html类型的邮件正文    attachments: [{    filename: 'a.jpg',//附件名称    path: './a.jpg',//附件的位置    cid: '123456789' //为附件添加一个引用名称}    ]};</code></pre><h2>邮箱检验的demo</h2><p>知道了邮箱校验的原理和知道怎么通过node来发送邮件，代码其实就简单多了，博客中就不粘贴具体的代码了，如果需要代码请在<a href="https://github.com/wuhuanhost/blog-demo" rel="external nofollow noopener noreferrer" target="_blank">node+express实现邮箱检验</a>查看。</p><h2>密码找回</h2><p>邮箱校验其实是为了找回密码服务的，而且他们的原理其实都差不多：很长一段时间当你打开一个以前注册的网站去登录的时候发现密码忘记了，点击了密码找回功能，系统会提示让输入一个注册邮箱或者用户名，然后会向这个邮箱发送一封带有特殊链接的邮件，让你登录邮箱去验证，成功登录邮箱并且点击连接就会跳转到一个重置密码的页面让你修改密码，修改成功就可以通过新密码登录系统了。（温馨提示：如果找回密码的时候网站直接把你以前的密码给你了，那么这个网站相对来说不安全，谨慎使用！）</p><h2>后记</h2><p>本文主要介绍了nodemailer的一些特性和基本使用方法和一些发邮件在具体项目中的应用，通过nodemailer我们也可以快速的开发一个简单的邮件发送客户端。</p>]]></content>
    
    <summary type="html">
    
      Node发送电子邮件
    
    </summary>
    
      <category term="后端开发" scheme="https://www.wuhuan.me/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="nodemailer" scheme="https://www.wuhuan.me/tags/nodemailer/"/>
    
      <category term="电子邮件" scheme="https://www.wuhuan.me/tags/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/"/>
    
      <category term="node.js" scheme="https://www.wuhuan.me/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>你以为你真理解用户的需求吗？</title>
    <link href="https://www.wuhuan.me/2017/04/13/know-user-real-need/"/>
    <id>https://www.wuhuan.me/2017/04/13/know-user-real-need/</id>
    <published>2017-04-13T02:21:36.000Z</published>
    <updated>2018-10-31T00:48:38.981Z</updated>
    
    <content type="html"><![CDATA[<h2>前言</h2><p>前两天客户在微信群里说某个产品列表页面的数据能不能一次性全部加载出来，不要每次点击“查看更多”按钮后新数据才出来。当时忙手头工作也没多想就很坚定的说：“那样肯定不行，以后数据量大的时候给服务器的压力会变大，查询速度变慢，用户等待的时间会变长”！然后就去忙工作了。</p><h2>分析</h2><p>下午和同事提到了早上客户在群里说的那个需求，同事就说：客户描述出来的需求不一定都是真实需求。然后我打开那个产品列表页面，不断的点击“查看更多”加载后面的数据，每一次加载的新数据看完了，都要重新点击按钮去加载后面的数据，在这个过程中给用户操作体验是不够友好的。联系到客户描述的“一次性加载全部的数据”需求结合起来。我恍然大悟，<strong>其实客户想要的效果是不点击“加载更多”按钮，直接向下滑动屏幕就可以看到源源不断的数据</strong>。这不就是滚动加载（无感知的加载数据，用户以为数据是一次性加载完的）！</p><h3>当前效果</h3><p><img src="/know-user-real-need/001.jpg" alt="现在的实现效果"></p><blockquote><p>上图：目前列表页面的效果，数据做了分页加载，上面也提到了，避免数据量多的时候，给服务器造成压力，满足技术要求！</p></blockquote><h3>客户描述的效果</h3><p><img src="/know-user-real-need/002.jpg" alt="客户描述的效果"></p><blockquote><p>上图：客户描述出来的列表页面的需求效果，由于客户不懂技术，只能感知前端的用户体验，正是这样原因客户才会提出把数据全部一次加载出来的<strong>假需求</strong>（满足了客户的需求，却不满足技术的要求）。</p></blockquote><h3>客户描述效果的改进</h3><p><img src="/know-user-real-need/003.jpg" alt="客户需求的改进"></p><blockquote><p>上图：明确了客户真正想要什么后的列表页面效果，针对客户的真实需求和技术之间的平衡点而实现，既满足客户的需求，又满足技术的要求，这才是好的设计。</p></blockquote><h2>结论</h2><p>这虽然是一个小的客户需求改进的例子，但是从里面我学到了两点很重要的东西。<strong>「 第一点、不要听用户说什么，而是要看用户想干什么。」<strong>和用户之间往往会有一个</strong>沟通盲区</strong>（不同的行业，隔行如隔山）而且我们和用户关注点不同，所以用户经常情况下是不能准确描述出来他们想要的需求的，所以只能去看他们想如何的使用我们的产品，去获取最真实的需求。**「 第二点、把自己当成用户，不断去试（各种尝试）用和思考自己的产品。 」**才能在技术和好的需求中找到一个平衡点，让你不断把产品迭代的更加完美。</p><p>抛砖引玉下，即使不是做技术的，只要是做和产品相关工作的都值得借鉴。</p>]]></content>
    
    <summary type="html">
    
      你以为你真理解用户的需求吗？
    
    </summary>
    
      <category term="产品思考" scheme="https://www.wuhuan.me/categories/%E4%BA%A7%E5%93%81%E6%80%9D%E8%80%83/"/>
    
    
      <category term="用户体验" scheme="https://www.wuhuan.me/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
      <category term="心得总结" scheme="https://www.wuhuan.me/tags/%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/"/>
    
      <category term="用户需求" scheme="https://www.wuhuan.me/tags/%E7%94%A8%E6%88%B7%E9%9C%80%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>网页文字竖排的几种实现方式</title>
    <link href="https://www.wuhuan.me/2017/04/05/text-landscape/"/>
    <id>https://www.wuhuan.me/2017/04/05/text-landscape/</id>
    <published>2017-04-05T02:21:36.000Z</published>
    <updated>2018-10-31T00:48:38.991Z</updated>
    
    <content type="html"><![CDATA[<p>古时候的书籍里面文字的书写方式都是从上到下从右向左书写的，我们可不可以在网页上实现这种文字排版效果，虽然现在竖排在网页上用的比较的少，但是我们可以在我们自己的个人网站或者博客介绍页面用竖排来排版，使网页样式看起来更加的丰富和复古！</p><p>通过一些尝试我找到了如下3中方式在网页上竖排文字的方法，各有各的缺点和优点，下面我们就来看看具体的方法和实现效果吧！</p><h3>方式1、css属性float实现文字竖排</h3><p>**实现原理：**把一短话的每一句放在一个div中，设置div的宽度和要显示的字体的大小一样（div的高度=字数×字体大小）,div就变成了一个竖条每一行就只能显示一个文字，第二个文字就会被挤到下一行，然后把div的float设置为right向右浮动排列。就达到了一首诗的竖排显示。</p><p><strong>代码实现:</strong></p><pre><code>&lt;style&gt;* {    font-family: Georgia;}#content {    position: absolute;    width: 1200px;    height: 400px;    left: 50%;    top: 50%;    margin-top: -300px;    margin-left: -600px;    border: 1px dashed #2f96b4;    padding-top: 50px;    border-radius: 20px;}#contentRemark {    position: absolute;    width: 1200px;    height: 300px;    left: 50%;    top: 56%;    margin-left: -600px;    padding-top: 50px;    text-indent: 2em;    font-size: 20px;    line-height: 2em;}.PoetryName {    font-size: xx-large;    font-weight: bold;    line-height: 1.5em;    width: 1.5em;    float: right;    font-size: 36px;    padding-top: 40px;    padding-right: 20px;}.PoetryPerson {    width: 1.5em;    float: right;    line-height: 2em;    padding-top: 70px;    font-size: 18px;    color: #d3524e;}.PoetryContent {    width: 1.5em;    float: right;    line-height: 1.5em;    padding-top: 30px;    font-size: 20px;}.PoetryContent:hover {    width: 1.5em;    float: right;    line-height: 1.5em;    padding-top: 30px;    font-size: 20px;    cursor: pointer;    color: #d3524e;}&lt;/style&gt;&lt;div id=&quot;content&quot;&gt;    &lt;div class=&quot;PoetryName&quot;&gt;爱莲说&lt;/div&gt;    &lt;div style=&quot;width:1.5em; float:right;&quot;&gt; &lt;/div&gt;    &lt;div class=&quot;PoetryPerson&quot;&gt;周 敦 颐 &lt;/div&gt;    &lt;div style=&quot;width:1.5em; float:right;&quot;&gt; &lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;水陆草木之花　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;可爱者甚蕃　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;晋陶渊明独爱菊　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;自李唐来　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;世人甚爱牡丹　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;予独爱莲之出淤泥而不染　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;濯清涟而不妖　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;中通外直　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;不蔓不枝　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;香远益清　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt; 亭亭净植　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt; 可远观而不可亵玩焉　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;予谓菊花之隐逸者也　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;牡丹花之富贵者也　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;莲花之君子者也　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;噫菊之爱　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt;陶后鲜有闻　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt; 莲之爱　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt; 同予者何人　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt; 牡丹之爱　&lt;/div&gt;    &lt;div class=&quot;PoetryContent&quot;&gt; 宜乎众矣　&lt;/div&gt;    &lt;div style=&quot;margin-left:40px;margin-top:-20px;&quot;&gt;![](http://upload-images.jianshu.io/upload_images/2054-980f1bc940e1b9b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/div&gt;&lt;/div&gt;</code></pre><p><a href="https://jsfiddle.net/Dreamer666/4uae1v45/7/" rel="external nofollow noopener noreferrer" target="_blank">通过float的方式实现文字竖排的demo</a></p><blockquote><p><strong>这种方式的优缺点：</strong> **优点：**网页文档的书写和我们平时正常书写网页时候一样，可以为每一行设置不同的显示样式。 **缺点：**如果一行文字比较长，没有办法换行~</p></blockquote><h3>方式2、css属性transform:rotate实现文字竖排</h3><p>**实现原理：**把一段话的每一个字放在一个span标签中(文字比较多可以通过js生成span)，然后把这些span标签放在一个大的div容器中，将容器div顺时针旋转90度，然后将容器中的span逆时针旋转90度，经过两次旋转之后就达到了竖排文字的需求。</p><p><strong>代码实现：</strong></p><pre><code>&lt;style&gt;.container {    position: absolute;    right: 300px;    margin-top: -200px;    width: 440px;    height: 1000px;    background-color: #FFFFFF;    padding-left: 36px;    font-family: &quot;楷体&quot;;    border: 1px solid #999999;    margin-left: 100px;    overflow-y: scroll;    overflow-x: hidden;    -webkit-transform: rotate(90deg);}/**每一行的容器（竖列）**/.container .items {    width: 445px;    height: 34px;    /*background-color: #EEEEEE;*/    /*border-left: 1px solid #999999;*/}.container .items .item {    display: inline-block;    width: 20px;    height: 20px;    font-size: 20px;    text-align: center;    line-height: 20px;    /*border-bottom: 1px solid #CCCCCC;*/}.container .items .item:hover {    background-color: pink;    cursor: pointer;    font-size: 22px;}.action1 {    width: 100px !important;    padding-left: 20px;}.rotate {    -webkit-transform: rotate(-90deg);}.style1 {    background-color: #ff6699;    color: #EEEEEE;}.style2 {    background-color: #4c98ce;    color: #EEEEEE;}#vertical div {    width: 1.5em;    float: right;}#vertical .title {    font-size: xx-large;    font-weight: bold;    line-height: 1em;}&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;    &lt;p&gt; &lt;/p&gt;    &lt;div class=&quot;items&quot;&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item rotate&quot; style=&quot;font-size:36px;font-weight:bold;&quot;&gt;爱&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item rotate&quot; style=&quot;font-size:36px;font-weight:bold;&quot;&gt;莲&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item rotate&quot; style=&quot;font-size:36px;font-weight:bold;&quot;&gt;说&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;p&gt; &lt;/p&gt;    &lt;/div&gt;    &lt;p class='action1'&gt;&lt;/p&gt;&lt;/div&gt;&lt;!--引入jquery依赖--&gt;&lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var arr = &quot;水陆草木之花，可爱者甚蕃。晋陶渊明独爱菊。自李唐来，世人甚爱牡丹。予独爱莲之出淤泥而不染，濯清涟而不妖，中通外直，不蔓不枝，香远益清，亭亭净植，可远观而不可亵玩焉。予谓菊，花之隐逸者也；牡丹，花之富贵者也；莲，花之君子者也。噫！菊之爱，陶后鲜有闻。莲之爱，同予者何人？牡丹之爱，宜乎众矣！&quot;.split(&quot;&quot;);var cHeight = $(&quot;.items&quot;).height();var textHeight = $(&quot;.item&quot;).height();var vCount = parseInt(cHeight / textHeight); //每列显示的字数var textArr = [];for (var i = 0; i &lt; arr.length; i++) {    if (i % 20 == 0) {textArr.push({    &quot;hanzi&quot;: arr[i]});    } else {textArr[textArr.length - 1].hanzi += arr[i];    }}var html = &quot;&quot;;for (var j = 0; j &lt; textArr.length; j++) {    html += &quot;&lt;div class='items'&gt;&quot;;    var tempArr = textArr[j].hanzi.split(&quot;&quot;);    console.log(tempArr)    for (var k = 0; k &lt; tempArr.length; k++) {if (/[&lt;&gt;《》！*(^)$%~!@#$…&amp;%￥—+=、。，；‘’“”：·`]/.test(tempArr[k])) {    html += &quot;&lt;div class='item' style='display:inline'&gt;&quot; + tempArr[k] + &quot;&lt;/div&gt;&quot;;} else {    html += &quot;&lt;div class='item rotate'&gt;&quot; + tempArr[k] + &quot;&lt;/div&gt;&quot;;}    }    html += &quot;&lt;/div&gt;&quot;;}$(&quot;.action1&quot;).after(html);&lt;/script&gt;</code></pre><p><a href="https://jsfiddle.net/Dreamer666/57y9yqva/2/" rel="external nofollow noopener noreferrer" target="_blank">通过transform:rotate方式实现文字竖排的demo</a></p><blockquote><p><strong>这种方式的优缺点：</strong> **优点：一大段文字也可以实现自动换行。 **缺点：在具体位置实现换行控制比较麻烦，而且每个字写都要用一个span标签来包住。</p></blockquote><h3>方式3、CSS属性write-mode实现文字竖排</h3><p><strong>writing-mode</strong>直译过来就是书写模式，它是为了控制文本布局而产生的，换句话说它就是用来实现文字竖排的，只不过文字竖排我们平时用的少，所以这个css属性也不常见，发现这个属性之前我还是在用一些其它方式（前两中方法）实现文字的竖排。</p><p><strong>writing-mode</strong>的属性比较多，详细请看<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode" rel="external nofollow noopener noreferrer" target="_blank">MDN</a>,文字竖排使用到的属性是<code>writing-mode:vertical-rl</code>从右向左竖排,<code>writing-mode:vertical-lr</code>从左向右竖排</p><p>代码实现</p><pre><code>&lt;style&gt;#content1 {    width: 900px;    height: 200px;    -webkit-writing-mode: vertical-rl;    writing-mode: vertical-rl;    padding-top: 40px;    font-size: 16px;}#content2 {    width: 900px;    height: 200px;    -webkit-writing-mode: vertical-lr;    writing-mode: vertical-lr;    padding-top: 40px;    font-size: 16px;}&lt;/style&gt;&lt;div id=&quot;content1&quot;&gt;    &lt;p style=&quot;letter-spacing:1em;font-size:20px;&quot;&gt;水调歌头 &lt;/p&gt;    &lt;p style=&quot;letter-spacing:.3em;font-size:18px;&quot;&gt;苏 轼&lt;/p&gt;    &lt;p&gt;明月几时有&lt;/p&gt;    &lt;p&gt;把酒问青天&lt;/p&gt;    &lt;p&gt;不知天上宫阙&lt;/p&gt;    &lt;p&gt;今夕是何年&lt;/p&gt;    &lt;p&gt;我欲乘风归去&lt;/p&gt;    &lt;p&gt;惟恐琼楼玉宇&lt;/p&gt;    &lt;p&gt;高处不胜寒&lt;/p&gt;    &lt;p&gt;起舞弄清影&lt;/p&gt;    &lt;p&gt;何似在人间&lt;/p&gt;    &lt;p&gt; 转朱阁&lt;/p&gt;    &lt;p&gt;低绮户&lt;/p&gt;    &lt;p&gt;照无眠&lt;/p&gt;    &lt;p&gt;不应有恨&lt;/p&gt;    &lt;p&gt;何事长向别时圆&lt;/p&gt;    &lt;p&gt;人有悲欢离合&lt;/p&gt;    &lt;p&gt;月有阴晴圆缺&lt;/p&gt;    &lt;p&gt;此事古难全&lt;/p&gt;    &lt;p&gt;但愿人长久&lt;/p&gt;    &lt;p&gt;千里共蝉娟&lt;/p&gt;&lt;/div&gt;&lt;hr&gt;&lt;div id=&quot;content2&quot;&gt;    &lt;p style=&quot;letter-spacing:1em;font-size:20px;&quot;&gt;水调歌头 &lt;/p&gt;    &lt;p style=&quot;letter-spacing:.3em;font-size:18px;&quot;&gt;苏 轼&lt;/p&gt;    &lt;p&gt;明月几时有&lt;/p&gt;    &lt;p&gt;把酒问青天&lt;/p&gt;    &lt;p&gt;不知天上宫阙&lt;/p&gt;    &lt;p&gt;今夕是何年&lt;/p&gt;    &lt;p&gt;我欲乘风归去&lt;/p&gt;    &lt;p&gt;惟恐琼楼玉宇&lt;/p&gt;    &lt;p&gt;高处不胜寒&lt;/p&gt;    &lt;p&gt;起舞弄清影&lt;/p&gt;    &lt;p&gt;何似在人间&lt;/p&gt;    &lt;p&gt; 转朱阁&lt;/p&gt;    &lt;p&gt;低绮户&lt;/p&gt;    &lt;p&gt;照无眠&lt;/p&gt;    &lt;p&gt;不应有恨&lt;/p&gt;    &lt;p&gt;何事长向别时圆&lt;/p&gt;    &lt;p&gt;人有悲欢离合&lt;/p&gt;    &lt;p&gt;月有阴晴圆缺&lt;/p&gt;    &lt;p&gt;此事古难全&lt;/p&gt;    &lt;p&gt;但愿人长久&lt;/p&gt;    &lt;p&gt;千里共蝉娟&lt;/p&gt;&lt;/div&gt;</code></pre><p><a href="https://jsfiddle.net/Dreamer666/5fjk4ozc/4/" rel="external nofollow noopener noreferrer" target="_blank">通过write-mode方式实现文字竖排的demo</a></p><blockquote><p><strong>这种方式的优缺点：</strong> **优点：实现文字竖排的方式比较的方便和优雅 **缺点：语法比较多，而且有两套不同的规范（IE和css3）！</p></blockquote><p>**注意事项：**write-mode会改变一些原有的规则，如我们队上面的content1中的p设置行高，那么行高会变成左右行距离而不是上下行距。</p>]]></content>
    
    <summary type="html">
    
      网页文字竖排的几种实现方式
    
    </summary>
    
      <category term="前端开发" scheme="https://www.wuhuan.me/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端笔记" scheme="https://www.wuhuan.me/tags/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用pillow生成分享图片</title>
    <link href="https://www.wuhuan.me/2017/04/01/create-image-by-pillow/"/>
    <id>https://www.wuhuan.me/2017/04/01/create-image-by-pillow/</id>
    <published>2017-04-01T12:05:36.000Z</published>
    <updated>2018-10-29T07:31:28.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>重复性的工作一定要交给计算机去做！</p></blockquote><p>有时候要为公司做一张宣传用的分享图片，很简单交给设计通过ps、AI做好就行了，但是如果一个网站要为每个用户生成一张专属的分享图片，如果让设计师一张一张的去做，哪设计师估计会崩溃。下面就来演示用程序来生成一张在简书的专属分享图片吧。</p><h3>程序生成分享图片分析</h3><p>程序生成分享图片不是说程序从无到有生成一张图片，而是说我们把设计师设计的设计稿抽象成一块一块的，然后通过程序算法去把它们组装起来成一张新图片。我们通过下面这张图片来说明吧！</p><p><img src="/create-image-by-pillow/mark.png" alt="我的简书分享图片标记图"></p><p>图中的绿色框内的内容是<strong>固定不变的</strong>，蓝色圆圈内的内容是<strong>变化的（<em>尤其是点赞数和文章总字数会随时变化的</em>）</strong>，我们可以这样做把背景和固定不变的内容让设计师做成一张背景图片，剩下的随时会变化的东西就通过程序绘制上去。</p><h3>本次用到的素材</h3><p><strong>模板图片（设计师设计好）</strong></p><p><img src="/create-image-by-pillow/template.jpg" alt="template.jpg"></p><p><strong>头像图片</strong></p><p><img src="/create-image-by-pillow/avatar.jpg" alt="avatar.jpg"></p><p><strong>二维码图片</strong></p><p><img src="/create-image-by-pillow/qrcode.png" alt="我的简书首页地址生成的二维码 qrcode.jpg"></p><h3>生成图片所需的工具说明</h3><p>我们使用python这门通用编程语言来处理图片，所以首先要在电脑上安装python,还用到了一个python图片处理的库<a href="www.mengxiangjia.info">Pillow</a>等python安装好之后通过<code>pip install Pillow</code>安装即可。[注意：Pillow的首字母P是大写的]</p><h3><strong>生成步骤</strong></h3><p>我们可以把模板图片理解成一张黑板，然后把头像图片，二维码图片，文字等贴在黑板正确的位置就完成了，这个过程就相当于我们向黑板贴东西的过程！</p><p>**step1:**先把头像贴上去，贴头像的时候这里会有一个问题，头像图片是正方形的，而我们要的效果是一个圆形的头像，这里需要写个函数专门处理圆形头像的问题。代码如下：</p><pre><code>&quot;&quot;&quot;将头像变成圆形绘制在背景图片上，然后将合成的图片对象返回&quot;&quot;&quot;def drawCircleAvatar(im,background):im = im.resize((170, 170));bigsize = (im.size[0] * 3, im.size[1] * 3)#遮罩对象mask = Image.new('L', bigsize, 0)draw = ImageDraw.Draw(mask) draw.ellipse((0, 0) + bigsize, fill=255)mask = mask.resize(im.size, Image.ANTIALIAS)im.putalpha(mask)background.paste(im, (235, 155), im)return background</code></pre><p>**step2:**绘制用户的昵称和写了多少字和收获多少个赞</p><pre><code>#绘制用户昵称font1 = ImageFont.truetype(&quot;simhei.ttf&quot;,32)drawImage=ImageDraw.Draw(back_img)drawImage.text((272, 366), unicode('梦想家','utf-8'), font=font1)#绘制用户写了多少字font2 = ImageFont.truetype(&quot;simhei.ttf&quot;,30)drawImage=ImageDraw.Draw(back_img)drawImage.text((110, 436), unicode('写了2388个字','utf-8'), font=font2)#绘制获取的点赞数font3 = ImageFont.truetype(&quot;simhei.ttf&quot;,30)drawImage=ImageDraw.Draw(back_img)drawImage.text((356, 436), unicode('收获10个赞','utf-8'), font=font3)</code></pre><p>**step3:**绘制二维码图片</p><pre><code>#将二维码图片粘贴在背景图片上region = qrcode_imgregion = region.resize((180, 180))back_img.paste(region,(230,860))</code></pre><p><strong>完整代码</strong></p><pre><code># -*- coding: utf-8 -*-from PIL import Image,ImageFont,ImageDrawimport time,sysreload(sys)sys.setdefaultencoding('utf-8')&quot;&quot;&quot;生成分享图片的方法&quot;&quot;&quot;def createShareImg(avatarUrl,qrcodeUrl,nickname,countWord,countLiked):startTime=time.time()#加载背景图片background=Image.open(ur'template.jpg')#加载头像图片avatar = Image.open(avatarUrl,&quot;r&quot;)qrcode_img = Image.open(qrcodeUrl,&quot;r&quot;)# 将背景图片和圆形头像合成之后当成新的背景图片back_img=drawCircleAvatar(avatar,background)#将二维码图片粘贴在背景图片上region = qrcode_imgregion = region.resize((180, 180))back_img.paste(region,(230,860))#绘制用户昵称font1 = ImageFont.truetype(&quot;simhei.ttf&quot;,32)drawImage=ImageDraw.Draw(back_img)drawImage.text((272, 366), unicode(nickname,'utf-8'), font=font1)#绘制用户写了多少字font2 = ImageFont.truetype(&quot;simhei.ttf&quot;,30)drawImage=ImageDraw.Draw(back_img)drawImage.text((110, 436), unicode(countWord,'utf-8'), font=font2)#绘制获取的点赞数font3 = ImageFont.truetype(&quot;simhei.ttf&quot;,30)drawImage=ImageDraw.Draw(back_img)drawImage.text((356, 436), unicode(countLiked,'utf-8'), font=font3)#保存图片到文件back_img.save('out.jpg') #保存图片endTime=time.time()print &quot;本次生成图片一共用时：&quot;.decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;)print str(endTime-startTime)+&quot;秒&quot;.decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;)&quot;&quot;&quot;将头像变成圆形绘制在背景图片上，然后将合成的图片对象返回&quot;&quot;&quot;def drawCircleAvatar(im,background):im = im.resize((170, 170));bigsize = (im.size[0] * 3, im.size[1] * 3)#遮罩对象mask = Image.new('L', bigsize, 0)draw = ImageDraw.Draw(mask)         #画椭圆的方法draw.ellipse((0, 0) + bigsize, fill=255)mask = mask.resize(im.size, Image.ANTIALIAS)im.putalpha(mask)background.paste(im, (235, 155), im)return backgroundif __name__=='__main__':avatarUrl=&quot;avatar.jpg&quot;qrcodeUrl=&quot;qrcode.jpg&quot;nickname=&quot;梦想家&quot;countWord=&quot;写了2388个字&quot;countLiked=&quot;收获10个赞&quot;createShareImg(avatarUrl,qrcodeUrl,nickname,countWord,countLiked)</code></pre><p>如果你要在本地运行此脚本命令，将此脚本复制保存成本地文件xxx.py然后把模板图片、你的头像图片、你的简书主页的二维码图片放在同一目录下，修改脚本中的参数，在当前目录打开命令行执行下面的命令：</p><pre><code>python xxx.py</code></pre><p>就会在当前目录生成一张属于你自己的简书分享图片了。</p><h3><strong>我的简书分享图片</strong></h3><p><img src="/create-image-by-pillow/result.jpg" alt="最终分享效果图"></p><p>分享图片的二维码链接为我的简书首页地址。</p><p>模板图片只用ps简单的做了一下，不好看请轻喷，如果你有好的模板请在评论处分享~</p><p>使用Pillow生成图片的效率还是比较高的windows系统下在<strong>1s</strong>以内，linux系统下<strong>0.1s</strong>以内，系统配置不同可能时间也有一些差别。</p><blockquote><p><a href="http://pillow.readthedocs.io/en/latest/index.html" rel="external nofollow noopener noreferrer" target="_blank">pillow官方文档地址</a>方便查看。</p></blockquote><blockquote><p><a href="https://github.com/wuhuanhost/mydemo/tree/master/try-learn.python/jianshu_share" rel="external nofollow noopener noreferrer" target="_blank">本文源码地址</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      使用pillow生成分享图片
    
    </summary>
    
      <category term="前端开发" scheme="https://www.wuhuan.me/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="pillow" scheme="https://www.wuhuan.me/tags/pillow/"/>
    
      <category term="python" scheme="https://www.wuhuan.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>golang学习笔记（二）go语言基础知识</title>
    <link href="https://www.wuhuan.me/2017/01/10/studygo-02-go-basic/"/>
    <id>https://www.wuhuan.me/2017/01/10/studygo-02-go-basic/</id>
    <published>2017-01-10T07:36:36.000Z</published>
    <updated>2018-10-31T00:48:38.989Z</updated>
    
    <content type="html"><![CDATA[<h2>1、go语言中的关键字</h2><p>go语言中一共有25个标识符（关键字）他们分别是：var、const、type、package、import、func、return、defer、go、select、interface、struct、break、case、continue、for、fallthrough、else、if、switch、goto、default、chan、type、map、range。 <a href="#4-2%E3%80%81go%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E8%A7%A3%E9%87%8A">关键字的作用见文章末尾附录</a></p><h2>2、go程序的组成</h2><p>下面就是一个简单的go程序，从下面的源码我们可以看出，一个基本的go程序由以下几部分组成，分别是<strong>包的声明</strong>、<strong>包的导入</strong>、<strong>常量的定义</strong>、<strong>变量的声明</strong>、<strong>注释</strong>、<strong>函数</strong>等组成，下面我们将详细的介绍go程序的组成部分。</p><pre><code>package main  #声明包import &quot;fmt&quot;  #导入包const ID int = 100var userName string = &quot;李明&quot;  #声明一个全局变量userName并且赋值func main(){     fmt.Println(&quot;hello world!!!&quot;);}</code></pre><h3>2.1、包的声明</h3><blockquote><p>go语言中通过关键字<code>package</code>来声明一个包，语法：<code>package &lt;包名&gt;</code>。</p></blockquote><p>假如我们声明一个main包<code>package main</code>，需要注意的是，包的声明语句必须源码文件的最上面，不然编译器就会报错。<strong>注意：声明为main包的文件中必须存在一个mian方法（入口方法），并且一个程序中有且只有一个main包和main方法。</strong></p><h3>2.2、包的导入</h3><h4>2.2.1、基本方式导入包</h4><p>导入包使用关键字<code>import</code>，语法<code>import &lt;包名&gt;</code>，例如导入<code>fmt</code>、<code>time</code>包的语句：</p><pre><code>import &quot;fmt&quot;import &quot;time&quot;</code></pre><h4>2.2.2、简写方式导入包</h4><p>如果有时候需要导入的包比较多，通过上面的方式会写很多的<code>import</code>，所以我们也可以通过简便的方式导入多个包，同样是使用关键字<code>import</code>，然后使用一对圆括号将所有要导入的包名写在圆括号中，每个包占一行。 同时导入<code>fmt</code>、<code>time</code>包的语句就变的简单了，如下：</p><pre><code>import (     &quot;fmt&quot;     &quot;time&quot;)</code></pre><blockquote><p>注意：如果导入的包没有使用，编译器编译的时候就会出现编译异常，会提示让我们去掉没有使用的包。</p></blockquote><h4>2.2.3、包的重命名</h4><p>有时候我们在使用自己写的程序包的时候，或者使用第三方程序包的时候，包名的重复在所难免，如果包名相同就会使程序运行出现错误，还有的时候我们觉的导入的包的名字比较长或者拼写比较麻烦，在这些场景下就可以通过包的重命名来重命名导入的包，举个例子：</p><pre><code>package mainimport (out &quot;fmt&quot;  //把fmt重命名为out     )main(){out.Println(&quot;hello world!!!&quot;)  //控制台打印hello world!!!}</code></pre><p>&lt;!--因为go语言的原码编码类型unicode所以重命名的包名可以是中文，但是避免不必要的问题建议不要使用中文重命名包。--&gt;</p><h3>2.3、代码注释</h3><p>代码注释也是go程序中的一部分。大型项目以后需要维护的时候，通过注释可以帮助我们快速理解程序。go语言的注释比较简单，和大多数编程语言差不多。</p><pre><code>package mainimport &quot;fmt&quot;/** ** 这是多行注释**/func main(){    fmt.println(&quot;hello world!&quot;)    //单行注释}</code></pre><h3>2.4、函数</h3><blockquote><p>go语言中通过关键字<code>func</code>来声明一个函数，如下：</p></blockquote><pre><code>package mainimport &quot;fmt&quot;/**** 声明一个自定义函数**/func myfunc(i int) int{     return 2 * i}func main(){     var r int=myfunc(1) //调用函数 并接受返回值     fmt.Println(r)   //打印返回值为2}</code></pre><h3>2.5、变量的声明</h3><blockquote><p>go语言中通过关键字<code>var &lt;变量名&gt; &lt;变量类型&gt;</code>来声明变量。</p></blockquote><p>声明一个变量并且赋值</p><pre><code>var i int=10 //声明一个整形变量，并且为它赋值为10</code></pre><p>声明多个变量和赋值</p><pre><code>var i,j int=10,20  //声明两个整型变量i和j并且赋值为i=10和j=20</code></pre><p>简写方式声明多个变量（只适用于全局变量）</p><pre><code>var (   id int   name string   sex bool     )</code></pre><blockquote><p>同时声明了三个变量整型变量id，字符串类型变量name,和bool类型的变量sex</p></blockquote><p>不指定变量类型来声明变量，声明变量的时候不指定类型，通过初始化值来确定变量的类型（这点和使用javascript,python的动态语言的用法很类似）</p><pre><code>var b=true;   //声明一个变量b，为它赋值true，所以它的类型应该是bool型的。</code></pre><p>简写方式变量声明和赋值（只适用于局部变量）</p><pre><code>name :=&quot;李明&quot; //等价于 var name string=&quot;liming&quot;</code></pre><h4>2.5.1、声明全局变量</h4><p>在函数体外声明的变量都是全局变量，全局变量可以在所有的函数中使用。</p><pre><code>package mainimport &quot;fmt&quot;var param string = &quot;这是一个全局变量,所有函数中都可以使用&quot;func main(){     fmt.Println(param)}</code></pre><blockquote><p>注意：全局变量的声明不能省略var关键字</p></blockquote><h4>2.5.2、声明局部变量</h4><p>在函数体内定义的变量都是局部变量，包括函数的参数和返回值参数。它们只能在当前函数使用。</p><pre><code>package mainimport &quot;fmt&quot;func myfunc(){   var param string = &quot;这是一个局部变量,变量的作用域在此函数中有效&quot;}func main(){    fmt.Println(param)   // 报错  &quot;undefined: param&quot;}</code></pre><p>在函数作用域中使用不会报错</p><pre><code>package mainimport &quot;fmt&quot;func myfunc(){   var param string = &quot;这是一个局部变量,变量的作用域在此函数中有效&quot;   fmt.Println(param)  // 打印param的值}func main(){    myfunc()}</code></pre><blockquote><p>全局变量和局部变量可以重名，但是局部变量的优先级要高于全局变量。</p></blockquote><pre><code>package mainimport &quot;fmt&quot;var param string = &quot;这是一个全局变量，该变量可以在所有函数中使用&quot;func myfunc(){   var param string = &quot;这是一个局部变量,变量的作用域在此函数中有效&quot;   fmt.Println(param)  // 打印出  &quot;这是一个局部变量,变量的作用域在此函数中有效&quot;}func main(){    myfunc()}</code></pre><h2>3、go语言中访问控制</h2><p>go语言中没有private，public关键字，那么我们该如何控制访问权限？go语言中通过约束命名（命名大小写）来实现对常量，变量，函数，接口，类型是否可以在外部包中使用。</p><h3>3.1、private类型</h3><p>go语言中约定如果命名首字母小写那么它就是<code>private</code>的，只能在当前包中可见。</p><h3>3.2、public类型</h3><p>go语言中约定如果命名首字母大写那么它就是<code>public</code>的，所有包中可见。现在我们就知道了为什么打印控制台的语句<code>fmt.Println('hello world')</code>的方法<code>Println</code>首字字母是大写的了吧。</p><h2>4、附录</h2><h3>4.1、go语言语句结尾的分号&quot;;&quot;</h3><p>go语言的语句结尾的分号可写可不写，因为编译器在编译源码的时候会默认在语句的结尾加上分号&quot;;&quot;,为了减少前键盘的次数，建议不要自己加分号。</p><h3>4.2、go中关键字的解释</h3><table><thead><tr><th>关键字</th><th>作用</th></tr></thead><tbody><tr><td>var和const</td><td>变量和常量的声明</td></tr><tr><td>package和import</td><td>包的声明和导入</td></tr><tr><td>func</td><td>声明函数和方法</td></tr><tr><td>return</td><td>定义函数返回值</td></tr><tr><td>defer</td><td>延时执行</td></tr><tr><td>go</td><td>用于并发编程</td></tr><tr><td>select</td><td>用于选择不同类型的通讯</td></tr><tr><td>interface</td><td>定义接口</td></tr><tr><td>struct</td><td>定义抽象数据类型</td></tr><tr><td>break、case、continue、for、fallthrough、else、if、switch、goto、default</td><td>流程控制</td></tr><tr><td>chan</td><td>channel通讯</td></tr><tr><td>type</td><td>声明自定义类型</td></tr><tr><td>map</td><td>声明map类型数据</td></tr><tr><td>range</td><td>迭代slice、map等数据</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      golang学习笔记（二）go语言基础知识
    
    </summary>
    
      <category term="后端开发" scheme="https://www.wuhuan.me/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="go语言" scheme="https://www.wuhuan.me/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>golang学习笔记（一）开发环境的搭建</title>
    <link href="https://www.wuhuan.me/2017/01/01/studygo-01-getstart/"/>
    <id>https://www.wuhuan.me/2017/01/01/studygo-01-getstart/</id>
    <published>2017-01-01T07:36:36.000Z</published>
    <updated>2018-10-31T00:48:38.988Z</updated>
    
    <content type="html"><![CDATA[<h2>下载安装golang</h2><p>下载地址:<a href="http://www.golangtc.com/download" rel="external nofollow noopener noreferrer" target="_blank">http://www.golangtc.com/download</a></p><p>通过上面的网址下载你操作系统对应的版本的程序进行安装，由于我用的window7所以下载了<code>go1.7.4.windows-386.msi</code>这个包，根据安装提示进行安装，安装好之后go使用的一些系统变量也会被设置好。但是我们需要自己设置一个gopath的环境变量。</p><h3>GOPATH的设置</h3><p><code>GOPATH</code> 环境变量指定了你的工作空间位置,除不能和go的安装目录相同，可以放在磁盘的任何位置。 点击开始-》计算机-》右键-属性-》高级系统设置-》环境变量-》新建系统变量： 变量名设置为：GOPATH 变量值设置为：E:\study-go</p><blockquote><p>多个GOPATH目录通过分号连接,例如<code>E:\\study-go;E:\\go-work</code></p></blockquote><p><code>ctrl+R</code>打开命令行窗口输入:<code>go env</code>输出如下则设置成功。</p><p><img src="/go-01-getstart/01.jpg" alt="go env"></p><h3>go语言项目基本目录结构介绍</h3><pre><code>E:\study-go  # 环境变量中设置的GOPATH路径     + bin    # 存放编译后的二进制可执行文件     + pkg    # 存放编译后的包文件     + src    # 源码目录（必须创建）+ github.com # 存放github上go的第三方包</code></pre><h3>go语言常用的命令</h3><ul><li><code>go run test.go</code>运行test.go</li><li><code>go build test.go</code>编译test.go</li><li><code>go get 'github.com/[第三方包名称]'</code>安装github的第三方包</li><li><code>go help</code>查看更多的go命令</li></ul><h2>包管理的安装</h2><blockquote><p>go语言通过<code>go get</code>命令安装的第三方会放在src目录下，这样团队开发的时候会把这些第三方包添加进版本控制里面，更新第三方包的时候会比较麻烦。在使用过nodejs的包管理工具npm，python的包管理工具pip,和ruby的包管理工具gem后,他们安装依赖的方式是那么的简单和方便，以至于现在学习go的时候的第一件就是去寻找购go的包管理工具，但是发现go语言到目前为止，官方还没有提供包管理工具，但是Go1.5引入了go vendor目录，用于将go编译时的应用路径搜索调整成为当前<code>项目目录/vendor目录</code>的方式。查资料发现go社区有很多基于此的第三方包管理的工具可以使用，这里就选择了[glide]<a href="https://github.com/Masterminds/glide" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Masterminds/glide</a> 这个工具来管理go项目的依赖。</p></blockquote><h3>初始化</h3><pre><code>glide init  #glide会扫描代码目录，创建一个glide.yaml文件，记录项目依赖</code></pre><h3>安装指定依赖包</h3><pre><code># &quot;#&quot;后面的0.9.2表示版本号，如果团队协作开发的时候最好指定版本号glide get github.com/json-iterator/go#0.9.2</code></pre><h3>查看项目依赖列表</h3><pre><code>glide list</code></pre><h3>更新项目依赖列表</h3><pre><code>glide update 或 glide up</code></pre><h3>glide.yaml文件说明</h3><pre><code>package: testimport:- package: github.com/json-iterator/go   #包所在的github仓库的地址  version: 0.9.2  #指定包的版本</code></pre><h3>安装项目依赖</h3><blockquote><p>我们也可以通过glide.yaml配置文件来安装依赖 该命令将会读取glide.lock文件，当glide.lock文件和glide.yaml不同步时，如glide.yaml发生改变，glide将会提供一个警告。运行glide up命令更新依赖树，将会重建glide.lock文件。</p></blockquote><pre><code># 安装整个项目的依赖包glide install</code></pre><h3>使用包管理后的工作目录的结构</h3><pre><code>E:\study-go  # 环境变量中设置的GOPATH路径     + bin    # 存放编译后的二进制可执行文件     + pkg    # 存放编译后的包文件     - src    # 源码目录  + github.com   - myproject  # 项目文件夹    + biz   # 源码目录    - a.go      - b.go      - hello-world.go      - glide.yaml  # glide配置文件    + vendor  # glide安装的项目依赖都在这个文件夹里    - glide.lock</code></pre><blockquote><p>有了glide.yaml文件和glide.lock文件，团队开发的时候就不需要吧第三方包纳入到版本控制里面，只需要将这两个文件纳入版本控制就行了。</p></blockquote><h2>学习文档</h2><blockquote><p>学习一门语言最好的教程就是官方提供的document、Q&amp;A、wiki、example等，但是的官网经常访问不了，所以我们可以通过下面的方式，来阅读官方文档。</p></blockquote><h3>本地浏览go官方文档</h3><pre><code>godoc -http=:6060</code></pre><p>打开命令窗口，执行上面的命令，打开浏览器输入：https://localhost:6060 就可以浏览go的官方文档了。</p><h3>其它文档</h3><p>下面是一些国内的关于golang的社区和资源。</p><ul><li>go官方文档中文版 ：<a href="http://zh-golang.appsp0t.com/" rel="external nofollow noopener noreferrer" target="_blank">http://zh-golang.appsp0t.com/</a></li><li>golang中文社区：<a href="http://studygolang.com/" rel="external nofollow noopener noreferrer" target="_blank">http://studygolang.com/</a></li><li>golang中国：<a href="http://golangtc.com/" rel="external nofollow noopener noreferrer" target="_blank">http://golangtc.com/</a></li><li>go项目搜索：<a href="https://gowalker.org/search?q=&amp;auto_redirect=true" rel="external nofollow noopener noreferrer" target="_blank">https://gowalker.org/search?q=&amp;auto_redirect=true</a></li></ul><h2>编辑器推荐</h2><blockquote><p>学习一门新语言的时候，能不用IDE就不要使用IDE、推荐使用文本编辑器、原因有两个。</p></blockquote><ul><li><p>一、由于ide集成东西比较多，体积大，占用内存多，响应速度慢。</p></li><li><p>二、ide会帮你完成很多的工作，程序编译到执行的过程会被隐藏，使你不能感受和理解整个程序从代码到执行完成的整个过程。</p></li></ul><blockquote><p>当然如果对一门语言熟练掌握了，用它来开发大型系统的时候在去使用IDE，那会帮你节省很多时间。</p></blockquote><p>这里我推荐使用<code>sublime text3</code>当然你也可以使用其它的编辑器如<code>vscode</code>，<code>atom</code>等，按照自己喜好来，我使用sublime text2主要是因为平时用它比较的多。</p><h2>hello world</h2><blockquote><p>环境搭建好了，下面通过一个“hello world”正式进入go语言编程的世界。</p></blockquote><p>新建一个文件<code>hello-world.go</code>,在文件中写入如下代码：</p><pre><code>package mainimport &quot;fmt&quot;func main(){  var str=&quot;我的第一个go语言代码&quot;  fmt.Printf(&quot;hello world!!!\n&quot;)  fmt.Printf(str+&quot;\n&quot;)}</code></pre><p>运行<code>go run hello-world.go</code></p><p><img src="/go-01-getstart/02.jpg" alt="go语言版 hello world"></p>]]></content>
    
    <summary type="html">
    
      golang学习笔记（一）开发环境的搭建
    
    </summary>
    
      <category term="后端开发" scheme="https://www.wuhuan.me/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="go语言" scheme="https://www.wuhuan.me/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>对Node.js分页查询（mysql）的封装</title>
    <link href="https://www.wuhuan.me/2016/12/27/nodejs-paging-util/"/>
    <id>https://www.wuhuan.me/2016/12/27/nodejs-paging-util/</id>
    <published>2016-12-27T07:32:23.000Z</published>
    <updated>2018-09-27T04:10:44.004Z</updated>
    
    <content type="html"><![CDATA[<h2>前言</h2><p>最近用node.js+mysql搭了一个web系统，后台管理界面涉及很多查询操作，而且查询的数据量还比较大，对于大批量数据显示的时候需要做分页处理，一来对于管理员来说数据展示比较友好，二来减轻服务器的数据读取压力和流量，java开发的时候分页通常会封装成了一个pagebean对象来简化分页查询，所以基于以前开发java的经验和思想，就用node封装了一个简单的mysql分页查询的对象PagingUtil。</p><p>由于比较简单，就直接上代码了。</p><h2>代码实现</h2><pre><code>var db = require('./db');var async = require('async');/** * 分页对象 * @param {[type]} totalRows   数据总条数 * @param {[type]} currentPage 当前显示的第几页 * @param {[type]} pageSize    每页显示的条数 */function PagingUtil(currentPage, pageSize) {    this.currentPage = currentPage === undefined ? 1 : parseInt(currentPage); //当前是第几页,默认为第一页    this.totalPages = 1; //最多能分多少页    this.totalRows = 0; //总数据条数    this.hasNextPage = false; //是否有下一页    this.hasPrevPage = false; //是否有上一页    this.pageSize = pageSize === undefined ? 10 : parseInt(pageSize); //每页显示几条数据，默认为10条    this.startRow = 0; //起始行    // this.endRow = 0; //结束行    this.table = &quot;&quot;; //要查询的表    this.queryFiled = &quot;&quot;; //要查询的字段    this.condition = &quot;&quot;; //查询条件    this.orderBy = &quot;&quot;; //排序    this.countSql = &quot;&quot;; //查询总条数的sql    this.pagingSql = &quot;&quot;; //分页sql    this.sortBy = &quot;&quot;; //排序类型    this.debug = false; //是否开启调试模式}/** * 排序类型 * @param {[type]} sortBy [description] */PagingUtil.prototype.setSortBy = function(sortBy) {    this.sortBy = sortBy;    return this;}/** * 设置按照什么字段排序 * @param {[type]} orderBy [description] */PagingUtil.prototype.setOrderBy = function(orderBy) {    this.orderBy = orderBy;    return this;}/** * 设置要查询的字段 * @param {[type]} filed [description] */PagingUtil.prototype.setQueryFiled = function(queryFiled) {    this.queryFiled = queryFiled;    return this;}/** * 设置查询条件 * @param {[type]} condition [description] */PagingUtil.prototype.setCondition = function(condition) {    this.condition = condition;    return this;}/** * 设置要查询的表 * @param {[type]} table [description] */PagingUtil.prototype.setTable = function(table) {    this.table = table;    return this;}/** * 获取分页sql * @return {[type]} [description] */PagingUtil.prototype.getPagingSql = function() {    this.queryFiled = this.queryFiled || &quot;*&quot;;    this.condition = this.condition || &quot;&quot;;    this.sortBy = this.sortBy || &quot;ASC&quot;;    var orderBy = &quot;&quot;;    if (this.orderBy === &quot;&quot; &amp;&amp; this.sortBy === &quot;&quot;) {orderBy = &quot;&quot;;    } else {if (this.orderBy === &quot;&quot;) {    orderBy = &quot;&quot;;} else {    orderBy = &quot;ORDER BY &quot; + this.orderBy + &quot; &quot; + this.sortBy;}    }    this.pagingSql = &quot;SELECT &quot; + this.queryFiled + &quot; FROM &quot; + this.table + &quot; &quot; + this.condition + &quot; &quot; + orderBy + &quot; LIMIT ?,?&quot;;    return this;}/** * 获取计算总条数的sql * @return {[type]} [description] */PagingUtil.prototype.getCountSql = function() {    this.countSql = &quot;SELECT COUNT(1) AS count FROM &quot; + this.table;    return this;}/** * 获取数据 * @return {[type]} [description] */PagingUtil.prototype.getListData = function() {    return this.listData;}/** * 设置每页需要显示的条数 */PagingUtil.prototype.setPageSize = function(pageSize) {    this.pageSize = parseInt(pageSize);    return this;}/** * 数据一共能分多少页 * @param {[type]} num [description] */PagingUtil.prototype.setTotalPages = function() {    var totalPages = 0;    totalPages = parseInt((this.totalRows - 1) / this.pageSize) + 1;    this.totalPages = totalPages;};/** * 设置当前第几页 * @param {[type]} currentPage [description] */PagingUtil.prototype.setCurrentPage = function(currentPage) {    this.currentPage = parseInt(currentPage);    return this;}/** * 是否打印sql语句 * @param {[type]} boolean [description] */PagingUtil.prototype.setDebug = function(boolean) {    this.debug = boolean;    return this;}/** * 计算起始行 * @return {[type]} [description] */PagingUtil.prototype.computedStartRow = function() {    if (this.currentPage === 1) { //第一页this.startRow = 0; //设置起始条数this.hasPrevPage = false;if (this.totalPages &gt; 1) {this.hasNextPage = true;} else {this.hasNextPage = false;}    } else if (1 &lt; this.currentPage &amp;&amp; this.currentPage &lt; this.totalPages) { //中间页this.hasNextPage = true;this.hasPrevPage = true;this.startRow = (this.currentPage - 1) * this.pageSize;    } else if (this.currentPage === this.totalPages) { //最后一页this.startRow = (this.currentPage - 1) * this.pageSize;this.hasNextPage = false;this.hasPrevPage = true;    }}/** * 分页方法 * @param  {Function} cb [description] * @return {[type]}      [description] */PagingUtil.prototype.paging = function(cb) {    //获取计算总条数的sql;    var sql1 = this.getCountSql().countSql;    var _this = this;    async.series([function(callback) {db.execSql(sql1, null, function(err, result) {    _this.totalRows = result[0].count; //总条数    _this.setTotalPages(); //总页数    _this.computedStartRow(); //计算起始行    callback();});    }, function(callback) {//分页sql语句var sql2 = _this.getPagingSql().pagingSql;var sqlParam = [_this.startRow, _this.pageSize];if (_this.debug) {    console.warn(&quot;分页sql语句&gt;&gt;&gt;:::::::::::::::::::::::::::::::::&quot;);    console.log(sql2);    console.warn(&quot;sql语句参数&gt;&gt;&gt;:::::::::::::::::::::::::::::::::&quot;);    console.log(sqlParam)}db.execSql(sql2, sqlParam, callback);    }], function(err, results) {if (_this.debug) {    console.warn(&quot;分页数据&gt;&gt;&gt;:::::::::::::::::::::::::::::::::&quot;);    console.log(results[1])}if (err) {    cb(err, null)} else {    var pagingData = {pagingData: results[1],currentPage: _this.currentPage,totalPages: _this.totalPages,totalRows: _this.totalRows,hasNextPage: _this.hasNextPage,hasPrevPage: _this.hasPrevPage,pageSize: _this.pageSize,startRow: _this.startRow    };    cb(null, pagingData)}    });}module.exports = PagingUtil;</code></pre><h2>使用</h2><pre><code>var PagingUtil=require('./paging_util');//使用方法exports.test = function(cb) {    var pageing = new page(); //实例化分页对象    pageing.setDebug(true)//开启调试模式.setCurrentPage(2)//显示第2页.setPageSize(2)//每页显示2条.setTable(&quot;books&quot;)//books表.setOrderBy(&quot;ID&quot;)//排序字段.setSortBy(&quot;ASC&quot;)//升序排列.paging(function(err, result) {    console.log(result)    cb(null, result)})}</code></pre><h3>查询返回的数据</h3><pre><code>{    &quot;pagingData&quot;: [{    &quot;id&quot;: 3,    &quot;book_name&quot;: &quot;编程珠玑（第2版·修订版）&quot;,    &quot;book_author&quot;: &quot;[美]乔恩·本特利（Jon Bentley）&quot;,    &quot;book_press&quot;: &quot;人民邮电出版社&quot;,    &quot;book_isbn&quot;: &quot;9787115357618&quot;},{    &quot;id&quot;: 4,    &quot;book_name&quot;: &quot;深入浅出Node.js&quot;,    &quot;book_author&quot;: &quot;朴灵&quot;,    &quot;book_press&quot;: &quot;人民邮电出版社&quot;,    &quot;book_isbn&quot;: &quot;9787115335500&quot;}    ],    &quot;currentPage&quot;: 2,    &quot;totalPages&quot;: 5,    &quot;totalRows&quot;: 9,    &quot;hasNextPage&quot;: true,    &quot;hasPrevPage&quot;: true,    &quot;pageSize&quot;: 2,    &quot;startRow&quot;: 2}</code></pre><h3>数据库测试数据</h3><p><img src="/%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E6%88%AA%E5%9B%BE.jpg" alt="分页查询"></p><h3><a href="https://github.com/wuhuanhost/node-utils/blob/master/src/paging_util.js" rel="external nofollow noopener noreferrer" target="_blank">源码见github</a></h3><h2>后记</h2><p>分页一般有两种实现方式，一种就是基于数据实现分页，数据库不同实现的分页方式也有所不同，另一种就是基于内存的分页，把所有的数据查询出来放在内存中，程序操作这份内存数据来实现分页，如果数据量不是太大，完全可以吧数据返回给前端，让前端去实现数据的分页。</p>]]></content>
    
    <summary type="html">
    
      对Node.js分页查询（mysql）的封装
    
    </summary>
    
      <category term="后端开发" scheme="https://www.wuhuan.me/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="node.js" scheme="https://www.wuhuan.me/tags/node-js/"/>
    
      <category term="mysql" scheme="https://www.wuhuan.me/tags/mysql/"/>
    
      <category term="分页查询" scheme="https://www.wuhuan.me/tags/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>使用TypeScript来写javascript代码</title>
    <link href="https://www.wuhuan.me/2016/03/15/tyscript-getStart/"/>
    <id>https://www.wuhuan.me/2016/03/15/tyscript-getStart/</id>
    <published>2016-03-15T06:21:36.000Z</published>
    <updated>2018-09-27T03:55:30.756Z</updated>
    
    <content type="html"><![CDATA[<p>从机器码到汇编语言再到c语言，java等的高级语言的过程其实在不断的抽象，目的就是让人们使用起来更加的方便和简单，想象一下如果让你用0和1来写程序会是一种什么样的体验。编程语言不断的演化，未来也越来越会趋于自然语言。</p><h2>为什么要使用<code>TypeScript</code>?</h2><p>了解为什么要使用TypeScript的时候我们有必要先了解什么是<strong>TypeScript</strong>是<code>javascript</code>的一个超级，添加了静态数据类型和基于类的面向对象编程语言的特性，由c#架构师主持开发。</p><p>我们可以把它理解成一种生成标准javascript语言的语言，用一张图来说明下他们之间的关系</p><p><img src="/typescript.jpg" alt="TypeScript编译javascript"></p><p>1、使用简单，会使java,c#,as3的看看文档就很容易上手了。 2、方便代码的重用（类，继承），而且TypeScript生成的代码很干净整洁。 3、更好的组织代码，尤其是大型项目（模块，命名空间） 4、我认为TypeScript是未来javascript的一种过渡。未来的ES标准应该向TypeScript靠拢。</p><p>&lt;!-- more --&gt;</p><h2>安装配置</h2><p>首先要在本机安装<code>Node.js</code>环境，然后使用Node.js的包管理工具<code>npm</code>安装TypeScript，安装命令如下：</p><pre><code>npm install -g TypeScript</code></pre><h2>简单使用</h2><p>安装好TypeScript后，在D盘新建一个名叫TypeScript-demo的目录，打开记事本在里面写入如下代码：</p><pre><code>class Animate {    animateType: string;//动物属性    animateName: string;//动物名称    // 构造方法    constructor(animateType: string, animateName: string) {this.animateType = animateType;this.animateName = animateName;    };    //移动的方法    run() {// return &quot;&lt;h1&gt;我是一只【&quot; + this.animateType + &quot;】我叫【&quot; + this.animateName + &quot;】我正在移动......&lt;/h1&gt;&quot;;console.log(&quot;我是一只【&quot; + this.animateType + &quot;】我叫【&quot; + this.animateName + &quot;】我正在移动......&quot;);    }}//实现继承class FlyAnimate extends Animate {    speed: number;//飞行速度    height: number;//飞行高度    constructor(speed: number, height: number, animateType: string, animateName: string) {super(animateType, animateName);this.height = height;this.speed = speed;    }    run() {//重写父类的移动方法super.run();//继承父类的移动方法//添加自己特有的移动方式console.log(&quot;我正在飞行，速度【&quot; + this.speed + &quot;】高度【&quot; + this.height+&quot;】米&quot;);    }}// let dog: Animate = new Animate(&quot;小狗&quot;, &quot;dog&quot;);// document.body.innerHTML = dog.run();//实例化Animate对象let dog: Animate = new Animate(&quot;小狗&quot;, &quot;dog&quot;);dog.run();console.log(&quot;-------------------------------------&quot;)//实例化FlyAnimate对象let fly:FlyAnimate=new FlyAnimate(10,100,&quot;小鸟&quot;,&quot;小小鸟&quot;);fly.run();</code></pre><p>然后把这段代码另存为<code>typescript-1.ts</code>到当前目录下的src目录下。一个typescript文件编写好了，现在编写好的文件是不能直接在浏览器中执行的，所以要在浏览器中运行这段代码，还需要通过typescript的编译器进行编译。</p><p>编译之前我们需要在当前目录下面新建立一个<code>tsconfig.json</code>，这个文件指定了这个项目的根文件和编译选项。这个文件可以是空文件，那么使用<code>tsc</code>进行编译的时候，编译器就会按照默认的编译选项进行编译。如果当前目录不存在这个文件，那么编译的时候编译器会逐级向上搜索父目录，当然也可在命令行中指定一个<code>tsconfig.json</code>文件，那么编译器会忽略当前目录下的<code>tsconfig.json</code>。</p><p>编译配置文件<code>tsconfig.json</code>文件内容</p><pre><code>{    &quot;compilerOptions&quot;: {      &quot;module&quot;: &quot;commonjs&quot;,    #使用commonjs编译&quot;target&quot;: &quot;es5&quot;,         #ECMAScript目标版本为ES5&quot;noImplicitAny&quot;: false,  #在表达式和声明上有隐含的'any'类型时报错。&quot;outDir&quot;: &quot;bin&quot;,         #编译后的输出目录&quot;rootDir&quot;: &quot;.&quot;,          #控制输出的目录结构&quot;removeComments&quot;:true,   #删除所有注释，除了以/!*开头的版权信息&quot;sourceMap&quot;: true,       #生成sourceMap &quot;sourceRoot&quot;:&quot;src&quot;,      #*.ts源文件的所在目录 &quot;outFile&quot;:&quot;bin/.js&quot;      #编译后多个文件合并成一个文件    },    &quot;exclude&quot;: [&quot;node_modules&quot;           #此目录会被编译器忽略     ]}</code></pre><p>通过<code>tsc</code>命令来编译</p><pre><code>tsc  ./src/typescript-1.ts  #编译指定的文件,不加参数将编译tscongif.json中所配置的所有配置</code></pre><p>运行结果 我是一只【小狗】我叫【dog】我正在移动...... ------------------------------------- 我是一只【小鸟】我叫【小小鸟】我正在移动...... 我正在飞行，速度【10】高度【100】米</p><p>我们可以到./bin目录中来看看TypeScript编译后的js文件的内容是怎样的。</p><pre><code>/**属性继承的核心,会迭代父类的所有属性，然后把这些属性添加到子类对象中**/var __extends = (this &amp;&amp; this.__extends) || function (d, b) {    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];    function __() { this.constructor = d; }    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());};/**匿名函数自动执行，然后把执行结果给Animate变量**/var Animate = (function () {    /**构造函数**/    function Animate(animateType, animateName) {this.animateType = animateType;this.animateName = animateName;    };    /**在Animate的原型链上添加一个run方法**/    Animate.prototype.run = function () {console.log(&quot;我是一只【&quot; + this.animateType + &quot;】我叫【&quot; + this.animateName + &quot;】我正在移动......&quot;);    };    return Animate;})();var FlyAnimate = (function (_super) {    __extends(FlyAnimate, _super);//继承父类的属性    function FlyAnimate(speed, height, animateType, animateName) {_super.call(this, animateType, animateName);this.height = height;this.speed = speed;    }    FlyAnimate.prototype.run = function () {    /**我们知道call()方法可以改变this的指向，_super替换this执行run()方法**/_super.prototype.run.call(this);console.log(&quot;我正在飞行，速度【&quot; + this.speed + &quot;】高度【&quot; + this.height + &quot;】米&quot;);    };    return FlyAnimate;})(Animate);var dog = new Animate(&quot;小狗&quot;, &quot;dog&quot;);dog.run();console.log(&quot;-------------------------------------&quot;);var fly = new FlyAnimate(10, 100, &quot;小鸟&quot;, &quot;小小鸟&quot;);fly.run();</code></pre><p>通过对注释我们对typescript编译后的js进行了简单的解读，你把两份代码放在一起看对比一下的时候你会发现用TypeScript写起来还是很舒服的。如果能通过一种简单的方式实现我们的需求，那么为什么不适用简单的方式呢。</p><p>更多关于的文档可以去TypeScript官网查看，或者<a href="https://zhongsp.gitbooks.io/TypeScript-handbook/content/doc/handbook/Enums.html" rel="external nofollow noopener noreferrer" target="_blank">TypeScript中文手册</a></p>]]></content>
    
    <summary type="html">
    
      TypeScript使用笔记
    
    </summary>
    
      <category term="前端开发" scheme="https://www.wuhuan.me/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端笔记" scheme="https://www.wuhuan.me/tags/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端工具" scheme="https://www.wuhuan.me/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>js常用的工具函数整理</title>
    <link href="https://www.wuhuan.me/2016/02/11/js-comm-remark/"/>
    <id>https://www.wuhuan.me/2016/02/11/js-comm-remark/</id>
    <published>2016-02-11T03:06:30.000Z</published>
    <updated>2018-10-31T00:48:38.978Z</updated>
    
    <content type="html"><![CDATA[<h3>随机从数组中获取几个元素</h3><pre><code class="language-javascript">/** * @param    {[type]}                 数组 * @param    {[type]}                 取出元素的个数  * @return   {[type]}                 [description] */function getRandomArrayElements(arr, count) {  var shuffled = arr.slice(0),    i = arr.length,    min = i - count,    temp, index;  while (i-- &gt; min) {    index = Math.floor((i + 1) * Math.random());    temp = shuffled[index];    shuffled[index] = shuffled[i];    shuffled[i] = temp;  }  return shuffled.slice(min);}</code></pre><h3>获取滚动条离顶端的距离</h3><pre><code class="language-javascript">function getScrollTop() {  var scrollPos;  if (window.pageYOffset) {scrollPos = window.pageYOffset;  } else if (document.compatMode &amp;&amp; document.compatMode != 'BackCompat'){scrollPos = document.documentElement.scrollTop;   } else if (document.body) {scrollPos = document.body.scrollTop;  }  return scrollPos;};</code></pre><h3>获取浏览器参数</h3><pre><code class="language-javascript">/** * @param    {[type]}     name        参数字符串  * @return   {[type]}                 [description] */function getQueryString(name) {    var reg = new RegExp('(^|&amp;)' + name + '=([^&amp;]*)(&amp;|$)', 'i');    var r = window.location.search.substr(1).match(reg);    if (r != null) {        return unescape(r[2]);    }    return null;}</code></pre><h3>判断是否在微信浏览器中</h3><pre><code class="language-javascript">function isWeixin() {  var ua = navigator.userAgent.toLowerCase();  if (ua.match(/MicroMessenger/i) == &quot;micromessenger&quot;) {    return true;  } else {    return false;  }};</code></pre><h3>cookies操作</h3><ul><li>设置cookies</li></ul><pre><code>/** * @param    {[type]}                 c_name        cookie名字 * @param    {[type]}                 value         cookie存的值 * @param    {[type]}                 expiredays    cookie过期时间 * @return   {[type]}                 [description] */function setCookie(c_name, value, expiredays) {  var exdate = new Date()  exdate.setDate(exdate.getDate() + expiredays)  document.cookie = c_name + &quot;=&quot; + escape(value) +    ((expiredays == null) ? &quot;&quot; : &quot;; expires=&quot; + exdate.toGMTString())};</code></pre><ul><li>获取cookies</li></ul><pre><code class="language-javascript">/** * @param    {[type]}                 name        cookie名字 * @return   {[type]}                 [description] */function getCookie(name) {  var search = name + &quot;=&quot; //查询检索的值  var returnvalue = &quot;&quot;; //返回值  if (document.cookie.length &gt; 0) {    sd = document.cookie.indexOf(search);    if (sd != -1) {      sd += search.length;      end = document.cookie.indexOf(&quot;;&quot;, sd);      if (end == -1){        end = document.cookie.length;      }      returnvalue = unescape(document.cookie.substring(sd, end))    }  }  return returnvalue;};</code></pre><h3>函数节流</h3><pre><code class="language-javascript">/** * @param    {[type]}                 method      延迟执行的函数 * @param    {[type]}                 delay       延迟多久执行 * @return   {[type]}                 duration    多长时间执行一次 */function throttle(method, delay, duration) {  var timer = null,    begin = new Date();  return function () {    var context = this,      args = arguments,      current = new Date();    clearTimeout(timer);    if (current - begin &gt;= duration) {      method.apply(context, args);      begin = current    } else {      timer = setTimeout(function () {        method.apply(context, args);      }, delay);    }  }};</code></pre>]]></content>
    
    <summary type="html">
    
      js常用的工具函数整理
    
    </summary>
    
      <category term="前端开发" scheme="https://www.wuhuan.me/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="tips" scheme="https://www.wuhuan.me/tags/tips/"/>
    
      <category term="前端笔记" scheme="https://www.wuhuan.me/tags/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
      <category term="javascript" scheme="https://www.wuhuan.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>html5，css3前端开发相关内容整理（持续更新）</title>
    <link href="https://www.wuhuan.me/2016/01/11/mobile-remark/"/>
    <id>https://www.wuhuan.me/2016/01/11/mobile-remark/</id>
    <published>2016-01-11T03:06:30.000Z</published>
    <updated>2018-10-31T00:48:38.983Z</updated>
    
    <content type="html"><![CDATA[<p>web、webapp前端开发过程中遇到的问题的常用处理方式整理和一些问题整理。</p><h3>常见问题处理方式</h3><p>&lt;!-- more --&gt;</p><h4><strong>单行文字垂直居中</strong></h4><p><code>html结构</code></p><pre><code class="language-html">&lt;div class=&quot;row&quot;&gt;单行文字垂直居中，单行文字垂直居中，单行文字垂直居中&lt;/div&gt;</code></pre><p><code>css样式</code></p><pre><code class="language-css">.row {display: block;height: 100px;line-height: 100px;width: 600px;background-color: #d5effc;}</code></pre><h4><strong>多行文字垂直居中</strong></h4><p><code>html结构</code></p><pre><code>&lt;div class=&quot;wrap&quot;&gt;&lt;div id=&quot;content&quot;&gt;多行文字垂直居中，多行文字垂直居中，多行文字垂直居中，多行文字垂直居中，多行文字垂直居中，多行文字垂直居中，多行文字垂直居中，多行文字垂直居中，多行文字垂直居中&lt;/div&gt;&lt;/div&gt;</code></pre><p><code>css样式</code></p><pre><code class="language-css">.wrap {display: table;width: 600px;height: 150px;background-color: #f780a4;}    #content {display: table-cell;vertical-align: middle;/**垂直居中**/}</code></pre><h4><strong>单行文本溢出</strong></h4><p><code>html结构</code></p><pre><code class="language-html">&lt;div class='text-overflow'&gt; 单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出，单行文本溢出 &lt;/div&gt;</code></pre><p><code>css样式</code></p><pre><code>&lt;!-- css --&gt;.text-overflow {width: 200px;/**设置显示的长度**/overflow: hidden;white-space: nowrap;text-overflow: ellipsis;text-overflow: ellipsis; /* IE/Safari */-ms-text-overflow: ellipsis;-o-text-overflow: ellipsis;/* Opera */-moz-binding: url(&quot;ellipsis.xml#ellipsis&quot;);/*FireFox*/background-color: #f4cd89;}</code></pre><h4><strong>文本内容自动换行</strong></h4><pre><code>word-break{word-wrap: break-word; word-break: normal; }</code></pre><h4><strong>多行文本溢出</strong></h4><p><code>html结构</code></p><pre><code class="language-html">&lt;div class='more-text-overflow'&gt;webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出，webkit浏览器多行文本溢出&lt;/div&gt;</code></pre><p><code>css结构</code></p><pre><code class="language-css">.more-text-overflow {width: 600px;display: -webkit-box;-webkit-line-clamp: 3;/*显示的行数,多余的行数将被隐藏*/-webkit-box-orient: vertical;overflow: hidden;background-color: #dcf791;}</code></pre><h4><strong>表格细边框设置</strong></h4><pre><code class="language-css">table,table th,table td{border:1px solid #999;border-collapse: collapse;}</code></pre><h4><strong>hr细边框</strong></h4><pre><code class="language-css">hr{height: 1px; background:#ccc; border:0;}</code></pre><h4><strong>禁止长按链接与图片弹出菜单</strong></h4><pre><code class="language-css">a, img {-webkit-touch-callout: none; }</code></pre><h4><strong>清除手机点击页面标签时候出现高亮</strong></h4><pre><code class="language-css">* {-webkit-tap-highlight-color: rgba(0,0,0,0);}</code></pre><h4><strong>改变选中的内容的样式</strong></h4><pre><code class="language-css">::selection{color:#ff0000;}::-moz-selection{color:#ff0000;}</code></pre><h4><strong>禁止用户选中文本内容</strong></h4><pre><code class="language-css">.content {-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;}</code></pre><h4><strong>高分辨率屏幕下1px处理方式</strong></h4><p><strong>全部细边框</strong></p><p><code>html结构</code></p><pre><code class="language-html">&lt;body&gt;&lt;div class=&quot;box retina-border rt-bd-all&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p><code>css样式</code></p><pre><code class="language-css">.box {width: 200px;heigth: 100px;box-sizing: border-box;border: 1px solid #aaa;}/* 去掉元素原有的边框 */.retina-border {position: relative;border: none;}/* 通过设置伪元素放大到2倍的宽高，设置1px边框，再缩小1倍，以达到0.5px边框的效果*/.retina-border:after {content: '';display: block;width: 200%;height: 200%;position: absolute;left: 0;top: 0;box-sizing: border-box;border: 0px solid #aaa;-webkit-transform-origin: left top;transform-origin: left top;-webkit-transform: scale(.5);transform: scale(.5);}.rt-bd-all:after {border-width: 1px;}</code></pre><p>** 部分变细边框**</p><p><code>html结构</code></p><pre><code class="language-html">&lt;body&gt;&lt;div class=&quot;box retina-border rt-bd-b&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p><code>css样式</code></p><pre><code class="language-css">.tr-bd-b:after {border-bottom-width: 1px;}.tr-bd-t:after {border-top-width: 1px;}.tr-bd-l:after {border-left-width: 1px;}.tr-bd-r:after {border-right-width: 1px;}</code></pre><h4><strong>垂直居中</strong></h4><p><code>html结构</code></p><pre><code>&lt;div class=&quot;wrap&quot;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>** 模仿单行文字居中的方式**</p><pre><code class="language-css">.wrap {width: 200px;height: 80px;line-height: 80px;}.box {display: inline-block;vertical-align:middle;}</code></pre><p>** 已知宽高，通过position:absolute;**</p><pre><code class="language-css">.wrap {width: 200px;height: 200px;position: relative;}.box {width: 100px;height: 80px;position: absolute;left: 50%;top: 50%;margin: -50px 0 0 -40px;}</code></pre><p><strong>未知宽高，通过css3属性 transfrom</strong></p><pre><code class="language-css">.wrap {width: 200px;height: 200px;position: relative;}.box {position: absolute;left: 50%;top: 50%;-webkit-transform: translateX(-50%) translateY(-50%);transform: translateX(-50%) translateY(-50%);}</code></pre><p>** 通过flex布局**</p><p><code>html结构</code></p><pre><code class="language-html">&lt;div class=&quot;wrap flexbox flexbox-center flexbox-middle&quot;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><code>css样式</code></p><pre><code class="language-css">.flexbox {display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex;display: flex;}/* 水平居中 */.flexbox-center {-webkit-box-pack: center; -moz-box-pack: center; -ms-flex-pack: center; -webkit-justify-content: center;justify-content: center;}/* 垂直居中 */.flexbox-middle {-webkit-box-align: center; -moz-box-align: center;-ms-flex-align: center; -webkit-align-items: center;align-items: center;}</code></pre><h4><strong>safari浏览器下div中的滚动卡顿不流畅解决方法</strong></h4><p><strong>div样式表中添加如下属性</strong></p><pre><code class="language-css">div {  -webkit-overflow-scrolling: touch;  overflow-scrolling: touch;}</code></pre><p><strong>或者使用</strong></p><p><code>iscroll.js</code></p><h4>让元素能看见但是不能点击</h4><pre><code>div{   pointer-events: none;  // div能看见但是不能点击}</code></pre><h3>开发常见问题整理</h3><h4><strong>ios(9.3.1)不支持css3属性calc嵌套使用，例如</strong></h4><p><code>width:calc( calc( 100% - 90px ) / 2);</code></p><h4>低版本手机不支持模板字符串</h4><blockquote><p>一些低版本的android手机不支持es6的模板字符串，如果js中存在模板字符串，js直接不会被加载解析。</p></blockquote><h4><strong>微信浏览器页面禁止下拉显示网址信息</strong></h4><blockquote><p><a href="https://gist.github.com/wuhuanhost/f978f14976a59bd96dbb567be594dee5" rel="external nofollow noopener noreferrer" target="_blank">禁止下拉显示网址信息</a></p></blockquote><p><a href="/demo/mobile-remark.html">查看效果</a></p>]]></content>
    
    <summary type="html">
    
      html5，css3前端开发相关内容整理（持续更新）
    
    </summary>
    
      <category term="前端开发" scheme="https://www.wuhuan.me/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="tips" scheme="https://www.wuhuan.me/tags/tips/"/>
    
      <category term="前端笔记" scheme="https://www.wuhuan.me/tags/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>canvas绘制运动的小球</title>
    <link href="https://www.wuhuan.me/2016/01/05/canvas-ball-sports/"/>
    <id>https://www.wuhuan.me/2016/01/05/canvas-ball-sports/</id>
    <published>2016-01-05T05:13:30.000Z</published>
    <updated>2018-09-27T01:15:23.975Z</updated>
    
    <content type="html"><![CDATA[<p>知乎的网页版登录界面的背景有很多运动的小球，小球和小球运动的时候之间还有连线，给人一种三维立体变换的效果，看着十分的不错，所以就试着做了个和知乎登录界面背景类似的效果，下面是我做好的效果的截图。</p><p><img src="/canvas-ball/ball.gif" alt="canvas绘制运动小球"></p><p>&lt;!-- more --&gt;</p><h2>实现思路</h2><p>首先了解下canvas中的动画原理？canvas中的动画其实是通过不断的<strong>重绘</strong>来实现动起来的效果的，打个比方一个小球初始的时候在画布的X,Y坐标记作<code>ball(x,y)</code>,然后每隔10毫秒更改小球的X,Y坐标为<code>ball(x+5,y+5)</code>(在当前X,Y坐标加5个像素) 并且清除整个画布，重新在画布上绘制更改坐标后小球，由于10毫秒非常的短，所有在视觉上给我们的感觉就是小球在不断运动着。canvas绘图的原理基本就是这样子。</p><ol><li><p>定义小球对象</p><pre><code>var ball = {xPointer: 100, //小球初始x坐标yPointer: 100, //小球初始y坐标vx: 1, //x方向的速度vy: 0.1, //y方向的速度x: 1, //x轴运动方向（1表示正方向，-1表示反方向）y: -1, //y轴运动方向color: &quot;blue&quot;, //小球颜色radius: 10, //小球半径};</code></pre></li><li><p>生成小球 demo中的小球有很多个，所以定义一个数组来装这些小球，小球的起始坐标、颜色、运动方向都不同所以这些值需要随机获取。</p><pre><code>    var ballList = []; //小球数组    var canvas,ctx;    //生成多个小球    function initBall() {canvas=document.getElementById(&quot;canvas&quot;);ctx=canvas.getContext(&quot;2d&quot;);//循环生成60个小球for (var i = 0; i &lt; 60; i++) {    // console.log(getIndex() + &quot;   &quot; + getIndex())    var ball = {};    ball.xPointer = getRandom(20, 980);//随机小球的X坐标    ball.yPointer = getRandom(20, 340);//随机小球的y坐标    ball.x = getIndex();//随机小球x轴运动方向    ball.y = getIndex();//随机小球的y轴运动方向    ball.vx = Math.random();//随机小球x轴方向速度    ball.vy = Math.random();//随机小球y轴方向速度    ball.radius = 9;//小球半径    ball.color = &quot;#&quot; + (&quot;00000&quot; + ((Math.random() * 16777215 + 0.5) &gt;&gt; 0).toString(16)).slice(-6);//随机小球颜色    ballList.push(ball);}    }   //随机一个1或者-1的方法   function getIndex() {var arr = [0, 1];var index = Math.floor((Math.random() * arr.length));if (index == 0) {    index = -1;}return index;    }    //获取两数之间的一个随机数的方法    function getRandom(first, last) {var choice = last - first + 1;return Math.floor(Math.random() * choice + first);    }</code></pre></li><li><p>通过canvas绘制小球 <strong>页面canvas标签</strong></p><pre><code>    &lt;canvas id=&quot;canvas&quot; width=&quot;1000&quot; height=&quot;360&quot; style='background-color: #EEEEEE;'&gt;&lt;/canvas&gt;</code></pre><p><strong>canvas绘制小球代码</strong></p><pre><code>function draw(ctx) {ctx.clearRect(0, 0, 1000, 360);//绘制前先清除画布for (var i = 0; i &lt; ballList.length; i++) {    ctx.save();    ctx.beginPath();    ctx.fillStyle = ballList[i].color;    ctx.arc(ballList[i].xPointer, ballList[i].yPointer, ballList[i].radius, 0, Math.PI * 2, false);    ctx.closePath();    ctx.fill();    ctx.restore();}}</code></pre></li><li><p>运动起来 小球运动的过程中使用了简单的碰撞检测，每次到达画布的边缘就改变小球的运动方向</p><pre><code>    //修改小球的状态，使小球动起来的方法    function update(ballList, ctx) {for (var i = 0; i &lt; ballList.length; i++) {    ballList[i].xPointer += ballList[i].vx * ballList[i].x;    ballList[i].yPointer += ballList[i].vy * ballList[i].y;    //碰撞检测 X轴方向    if (ballList[i].xPointer + ballList[i].radius &gt;= canvas.width || ballList[i].xPointer - ballList[i].radius &lt;= 0) {ballList[i].x = ballList[i].x * -1;    }    //碰撞检测 Y轴方向    if (ballList[i].yPointer + ballList[i].radius &gt;= canvas.height || ballList[i].yPointer - ballList[i].radius &lt;= 0) {ballList[i].y = ballList[i].y * -1;    }}    }</code></pre></li><li><p>绘制小球和小球之间的连线</p><pre><code>//小球之间连线    function drawLine(ballList, ctx) {for (var i = 0; i &lt; ballList.length; i++) {    for (var j = 0; j &lt; ballList.length; j++) {var xx = Math.pow((ballList[i].xPointer - ballList[j].xPointer), 2);var yy = Math.pow((ballList[i].yPointer - ballList[j].yPointer), 2);var zz = Math.sqrt(xx + yy);//判断两个小球如果之间距离在20到100之间，就绘制一条直线if (zz &lt;= 100&amp;&amp;zz&gt;=20) {console.log(zz)    ctx.save();    ctx.beginPath();    ctx.strokeStyle=&quot;#999999&quot;;    ctx.lineWidth=0.1;    // ctx.strokeStyle= &quot;#&quot; + (&quot;00000&quot; + ((Math.random() * 16777215 + 0.5) &gt;&gt; 0).toString(16)).slice(-6);    ctx.moveTo(ballList[i].xPointer, ballList[i].yPointer);    ctx.lineTo(ballList[j].xPointer,ballList[j].yPointer);    ctx.closePath();    ctx.stroke();    ctx.restore();}   }}    }</code></pre></li><li><p>运行</p><pre><code>(function(){    initBall();//生成小球    //计时器    setInterval(function() {// console.log(selectfrom(0, 600) + &quot;         &quot; + selectfrom(0, 600));draw(ctx);//绘制update(ballList, ctx);//修改小球状态drawLine(ballList, ctx);//画线    }, 24)})();</code></pre></li></ol><h3>其它</h3><ul><li><p>由于代码比较简单和少，也就没有做封装处理</p></li><li><p>通过修改小球的半径后得到了另一种不错的显示效果，如下图</p></li></ul><p><img src="/canvas-ball/ball1.gif" alt="修改小球半径后的效果"></p><blockquote><p>到此一个canvas小球运动效果的demo做完了，看着是不是有一种3d变换效果。</p></blockquote><h2>参考文档</h2><p>canvas参考文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Basic_usage" rel="external nofollow noopener noreferrer" target="_blank">canvas api</a></p>]]></content>
    
    <summary type="html">
    
      canvas绘制运动的小球
    
    </summary>
    
      <category term="前端开发" scheme="https://www.wuhuan.me/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="canvas" scheme="https://www.wuhuan.me/tags/canvas/"/>
    
      <category term="Demo" scheme="https://www.wuhuan.me/tags/Demo/"/>
    
  </entry>
  
  <entry>
    <title>canvas中遮罩效果的实现方法</title>
    <link href="https://www.wuhuan.me/2015/12/31/canvas-mask/"/>
    <id>https://www.wuhuan.me/2015/12/31/canvas-mask/</id>
    <published>2015-12-31T02:20:25.000Z</published>
    <updated>2018-09-27T01:15:23.978Z</updated>
    
    <content type="html"><![CDATA[<p>最近做的一个项目需要支持多终端，网页版需要使用html5中canvas画布对象对一组数据进行渲染还原，但是在实际实现过程中遇到了一个问题，canvas中没有mask（遮罩）层的概念，所以一些效果实现不了，最后翻看文档的时候发现可以通过Context对象的<code>globalCompositeOperation</code>属性或者Context的<code>clip()</code>裁剪路径方法实现遮罩的效果。</p><p>&lt;!-- more --&gt;</p><h2>globalCompositeOperation属性介绍</h2><p>接下来先详细了解下Context的<code>globalCompositeOperation</code>的各种值描述，由于项目不便演示最后我们通过它来实现一个<strong>刮刮卡</strong>的效果。</p><table><thead><tr><th style="text-align:left">属性值</th><th style="text-align:left">描述</th><th style="text-align:right">显示效果</th></tr></thead><tbody><tr><td style="text-align:left"><strong>source-over (default)</strong></td><td style="text-align:left">新图形会覆盖在原有内容之上</td><td style="text-align:right"><img src="/canvas-mask/source-over.png" alt="canvas实现mask效果"></td></tr><tr><td style="text-align:left"><strong>destination-over</strong></td><td style="text-align:left">会在原有内容之下绘制新图形</td><td style="text-align:right"><img src="/canvas-mask/destination-over.png" alt="canvas实现mask效果"></td></tr><tr><td style="text-align:left"><strong>source-in</strong></td><td style="text-align:left">新图形会仅仅出现与原有内容重叠的部分。其它区域都变成透明的</td><td style="text-align:right"><img src="/canvas-mask/source-in.png" alt="canvas实现mask效果"></td></tr><tr><td style="text-align:left"><strong>destination-in</strong></td><td style="text-align:left">原有内容中与新图形重叠的部分会被保留，其它区域都变成透明的</td><td style="text-align:right"><img src="/canvas-mask/destination-in.png" alt="canvas实现mask效果"></td></tr><tr><td style="text-align:left"><strong>source-out</strong></td><td style="text-align:left">结果是只有新图形中与原有内容不重叠的部分会被绘制出来</td><td style="text-align:right"><img src="/canvas-mask/source-out.png" alt="canvas实现mask效果"></td></tr><tr><td style="text-align:left"><strong>destination-out</strong></td><td style="text-align:left">原有内容中与新图形不重叠的部分会被保留</td><td style="text-align:right"><img src="/canvas-mask/destination-out.png" alt="canvas实现mask效果"></td></tr><tr><td style="text-align:left"><strong>source-atop</strong></td><td style="text-align:left">新图形中与原有内容重叠的部分会被绘制，并覆盖于原有内容之上</td><td style="text-align:right"><img src="/canvas-mask/source-atop.png" alt="canvas实现mask效果"></td></tr><tr><td style="text-align:left"><strong>destination-atop</strong></td><td style="text-align:left">原有内容中与新内容重叠的部分会被保留，并会在原有内容之下绘制新图形</td><td style="text-align:right"><img src="/canvas-mask/destination-atop.png" alt="canvas实现mask效果"></td></tr><tr><td style="text-align:left"><strong>lighter</strong></td><td style="text-align:left">两图形中重叠部分作加色处理</td><td style="text-align:right"><img src="/canvas-mask/lighter.png" alt="canvas实现mask效果"></td></tr><tr><td style="text-align:left"><strong>darker</strong></td><td style="text-align:left">两图形中重叠的部分作减色处理</td><td style="text-align:right"><img src="/canvas-mask/darker.png" alt="canvas实现mask效果"></td></tr><tr><td style="text-align:left"><strong>xor</strong></td><td style="text-align:left">重叠的部分会变成透明</td><td style="text-align:right"><img src="/canvas-mask/xor.png" alt="canvas实现mask效果"></td></tr><tr><td style="text-align:left"><strong>copy</strong></td><td style="text-align:left">只有新图形会被保留，其它都被清除掉</td><td style="text-align:right"><img src="/canvas-mask/copy.png" alt="canvas实现mask效果"></td></tr></tbody></table><blockquote><p><strong><em><code>蓝色</code></em></strong> 表示先绘制的图形、<strong><em><code>红色</code></em></strong> 表示后绘制的图形</p></blockquote><p><strong>浏览器支持：</strong> <code>Internet Explorer 9</code>、<code>Firefox</code>、<code>Opera</code>、<code>Chrome</code>、<code>Safari</code> 支持globalCompositeOperation 属性</p><p>通过Context的<code>globalCompositeOperation</code>我们可以灵活的掌握绘制图形之间层叠显示关系，做出很多漂亮的显示效果。接下来我们就使用<code>globalCompositeOperation=destination-out</code>来实现一个刮刮卡的效果。</p><h2>globalCompositeOperation属性应用</h2><p><strong>刮刮卡实现效果图</strong></p><p><img src="/canvas-mask/canvas-mask.gif" alt="canvas实现刮刮卡效果"></p><p><strong>实现原理</strong></p><ol><li>在页面上放一个<code>div</code>容器，设置这个div的宽高、把<code>机器猫</code>的图片设为背景,</li><li>在div中放一个<code>canvas</code>标签，设置canvas的<strong>宽高</strong>和父容器div的一样。</li><li>获取canvas的context对象绘制一个以灰色为背景宽高和canvas宽高相同的矩形，这样机器猫背景图就被遮住了，只能看见一个灰色的背景。</li><li>canvas绑定鼠标mousedown,mousemove和mouseup事件(移动端绑定事件分别是：touchstart,touchmove,touchend)，设置鼠标按下标志，鼠标按下或者鼠标按下并且移动时记录鼠标坐标值。</li><li>鼠标点击或者按住鼠标移动的时候开始绘图，绘图的时候设置<code>context.globalCompositeOperation='destination-out'</code>根据上面属性的解释，原有图形（灰色矩形）与新图形（画的线条）不重叠的部分会被保留，所以画过线条的部分不会被保留就可以看见下面机器猫图片背景了。</li><li>鼠标抬起设置鼠标按下标志为false，清空坐标数组。</li></ol><p><strong>具体代码</strong></p><p>html代码（canvas动态创建的）</p><pre><code>&lt;div id='div' style='width:540px;min-height:360px;background:url(&quot;../test.jpg&quot;) no-repeat'&gt;&lt;/div&gt;</code></pre><p>javascript代码</p><pre><code>function init() {if (!document.getElementById(&quot;myCanvas&quot;)) {    var width = &quot;&quot;;    var height = &quot;&quot;;    var canvas = document.createElement(&quot;canvas&quot;);    width = document.getElementById(&quot;div&quot;).offsetWidth;    height = document.getElementById(&quot;div&quot;).offsetHeight;    canvas.setAttribute(&quot;width&quot;, width + &quot;px&quot;);    canvas.setAttribute(&quot;height&quot;, height + &quot;px&quot;);    canvas.setAttribute(&quot;style&quot;, &quot;border:1px solid green&quot;);    canvas.id = &quot;myCanvas&quot;;    document.getElementById(&quot;div&quot;).appendChild(canvas);}var myCanvasObject = document.getElementById(&quot;myCanvas&quot;);var ctx = myCanvasObject.getContext(&quot;2d&quot;);//绘制黑色矩形ctx.beginPath();ctx.fillStyle = &quot;#939393&quot;;ctx.rect(0, 0, width, height);ctx.closePath();ctx.fill();var isDown = false; //鼠标是否按下标志var pointerArr = []; //鼠标移动坐标数组var xPointer = 0;//鼠标当前x坐标var yPointer = 0;//鼠标当前y坐标//pc，移动事件兼容写法var hastouch = &quot;ontouchstart&quot; in window ? true : false,tapstart = hastouch ? &quot;touchstart&quot; : &quot;mousedown&quot;,tapmove = hastouch ? &quot;touchmove&quot; : &quot;mousemove&quot;,tapend = hastouch ? &quot;touchend&quot; : &quot;mouseup&quot;;//鼠标按下myCanvasObject.addEventListener(tapstart, function(event) {    this.style.cursor = &quot;move&quot;;    isDown = true;    xPointer = hastouch ? e.targetTouches[0].pageX : e.clientX - this.offsetLeft;    yPointer = hastouch ? e.targetTouches[0].pageY : e.clientY - this.offsetTop;;    pointerArr.push([xPointer, yPointer]);    circleReset(ctx);});//鼠标按下后拖动myCanvasObject.addEventListener(tapmove, function(event) {    if (isDown) {xPointer = hastouch ? e.targetTouches[0].pageX : e.clientX - this.offsetLeft;;yPointer = hastouch ? e.targetTouches[0].pageY : e.clientY - this.offsetTop;;pointerArr.push([xPointer, yPointer]);circleReset(ctx);    }});//鼠标抬起取消事件myCanvasObject.addEventListener(tapend, function(event) {    isDown = false;    pointerArr = [];});//圆形橡皮檫function circleReset(ctx) {    ctx.save();    ctx.beginPath();    ctx.moveTo(pointerArr[0][0], pointerArr[0][1]);    ctx.lineCap = &quot;round&quot;;　　 //设置线条两端为圆弧    ctx.lineJoin = &quot;round&quot;;　　 //设置线条转折为圆弧    ctx.lineWidth = 60;    ctx.globalCompositeOperation = &quot;destination-out&quot;;    if (pointerArr.length == 1) {ctx.lineTo(pointerArr[0][0] + 1, pointerArr[0][1] + 1);    } else {for (var i=1;i&lt;pointerArr.length;i++) {    ctx.lineTo(pointerArr[i][0], pointerArr[i][1]);    ctx.moveTo(pointerArr[i][0], pointerArr[i][1]);}    }    ctx.closePath();    ctx.stroke();    ctx.restore();}}</code></pre><h2>参考文档</h2><p>canvas参考文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Basic_usage" rel="external nofollow noopener noreferrer" target="_blank">canvas api</a></p>]]></content>
    
    <summary type="html">
    
      canvas中遮罩效果的实现方法
    
    </summary>
    
      <category term="前端开发" scheme="https://www.wuhuan.me/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="canvas" scheme="https://www.wuhuan.me/tags/canvas/"/>
    
      <category term="Demo" scheme="https://www.wuhuan.me/tags/Demo/"/>
    
  </entry>
  
  <entry>
    <title>Express连接mysql数据库实现简单的数据查询</title>
    <link href="https://www.wuhuan.me/2015/12/25/nodejs-express-mysql-basic/"/>
    <id>https://www.wuhuan.me/2015/12/25/nodejs-express-mysql-basic/</id>
    <published>2015-12-25T03:32:23.000Z</published>
    <updated>2018-09-27T03:54:45.180Z</updated>
    
    <content type="html"><![CDATA[<h2>第一步，安装node.js</h2><p>打开<a href="http://www.nodejs.org" rel="external nofollow noopener noreferrer" target="_blank">node.js官网</a>，根据系统选择对应的稳定版本进行下载，windows下建议下载<code>.msi</code>为后缀的安装文件。因为安装好后环境变量也会帮你配置好，新版的nodejs安装好包管理工具<code>npm</code>也会默认帮你安装好。</p><p>&lt;!-- more --&gt;</p><p>安装好后使用<code>win+r</code>组合键打开运行对话框，在对话框中输入cmd打开命令窗口，输入</p><pre><code> node -v</code></pre><p>如果不报错，并且打印出版本号信息</p><pre><code>v4.2.4   # 我的nodejs版本号</code></pre><p>然后输入</p><pre><code> npm -v</code></pre><p>如果不报错，并且打印出版本号信息</p><pre><code>3.5.3     # 我的npm版本号</code></pre><p>那么说明nodejs和npm都安装成功了，我使用的nodejs的版本号是v4.2.4 LTS这是一个长期支持的版本。</p><h2>第二步，数据库中建立一张测试表</h2><p>打开***<code>Navicat</code>***连接mysql，新建一个测试数据库<code>bookinfo</code>,选中<code>bookinfo</code>数据库，新建查询编辑器并且输入如下建表语句建立一张<code>books</code>测试表</p><pre><code>DROP TABLE IF EXISTS books;CREATE TABLE  books (id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,#主键book_name VARCHAR(200) NOT NULL,#书名book_author VARCHAR(200) NOT NULL,#作者 book_press VARCHAR(200) NOT NULL,#出版社book_isbn VARCHAR(200) NOT NULL#isbn)ENGINE=INNODB DEFAULT  CHARSET=utf8 AUTO_INCREMENT=1</code></pre><p>添加几条测试数据</p><pre><code>INSERT INTO books VALUES(null,'Java编程思想（第4版）','[美]埃克尔','机械工业出版社','9787111213826');INSERT INTO books VALUES(null,'算法导论（原书第3版）','（美）Thomas H.Cormen，Charles E.Leiserson，Ronald L.Rivest，Clifford Stein','机械工业出版社','9787111407010');INSERT INTO books VALUES(null,'编程珠玑（第2版·修订版）','[美]乔恩·本特利（Jon Bentley）','人民邮电出版社','9787115357618');INSERT INTO books VALUES(null,'深入浅出Node.js','朴灵','人民邮电出版社','9787115335500');INSERT INTO books VALUES(null,'Node.js权威指南','陆凌牛','机械工业出版社','9787111460787');INSERT INTO books VALUES(null,'HTML5权威指南','（美）弗里曼','人民邮电出版社','9787115338365');</code></pre><h2>第三步，全局安装所需的依赖包和工具包</h2><p>安装<code>express</code>nodejs中的一个web开发框架</p><pre><code> npm install -g express   #安装</code></pre><p>安装<code>express-generator</code>应用生成器</p><pre><code> npm install express-generator -g  #可以帮我们快速创建一个应用的基本结构</code></pre><p>安装<code>mysql</code>的nodejs驱动包</p><pre><code> npm install -g mysql      #全局安装驱动包</code></pre><p>安装<code>node supervisor</code>工具包</p><pre><code> npm install -g supervisor  #安装</code></pre><blockquote><p>node.js程序启动后，每次修改了文件必须重新启动服务才会生效，这样的设计提高了性能，却不利于开发调试，supervisor可以帮助我们监视代码的变动，一旦代码有所改变就自动重启服务。</p></blockquote><h2>第四步，代码实现</h2><p>使用express-generator生成express基本项目结构</p><pre><code> express book-web  #生成一个项目 cd book-web#进入生成的项目 npm install      #安装项目依赖包</code></pre><p>如下就是express-generator帮我们创建的项目的基本结构</p><pre><code>.├── app.js├── bin│   └── www#项目的入口├── package.json├── public#静态资源文件夹│   ├── images#图片资源│   ├── javascripts#javascript文件│   └── stylesheets#样式文件│       └── style.css├── routes#路由文件夹│   ├── index.js│   └── users.js└── views#视图文件夹     ├── error.jade    ├── index.jade    └── layout.jade</code></pre><p>安装mysql驱动包到项目中</p><pre><code> npm install mysql -save    # 安装到项目</code></pre><p>在<code>routes</code>中添加一个<code>book.js</code>文件，将如下内容写入<code>book.js</code>中</p><pre><code>//加载expressvar express = require('express');//通过express获取Router对象var router = express.Router();//加载bookDaovar bookDao = require('../dao/bookDao');//拦截/book请求router.get('/', function(req, res, next) {    res.send('respond with a resource');});/** * 查询全部书籍信息 * 访问链接 localhost:3000/book/queryAll * @param  {[type]} req   [description] * @param  {[type]} res   [description] * @param  {[type]} next) {               bookDao.query(req, res, next);} [description] * @return {[type]}       [description] */router.get('/queryAll', function(req, res, next) {    bookDao.queryAll(req, res, next);});module.exports = router;</code></pre><p>项目根目录新建<code>dao</code>文件夹，并且在文件夹中新建<code>bookDao.js</code>,写入如下代码</p><pre><code>//加载mysql驱动var mysql = require('mysql');//创建连接  var client = mysql.createConnection({    host: '192.168.1.200', //数据库的ip地址    user: 'root',    password: 'root',    database: 'bookinfo',    port: 3306});//连接client.connect();module.exports = {    queryAll: function(req, res, next) {client.query('select * from books', function(err, results, fields) {    if (err) {throw err;    }    if (results) {// 返回json// res.json(results);var arr = [];for (var i = 0; i &lt; results.length; i++) {    console.log(&quot;%d\t%s\t%s&quot;, results[i].id, results[i].book_name, results[i].book_author, results[i].book_press, results[i].book_isbn);    var book = {};    book.id = results[i].id;    book.name = results[i].book_name;    book.author = results[i].book_author;    book.press = results[i].book_press;    book.isbn = results[i].book_isbn;    arr.push(book);}//返回视图res.render('book', {    &quot;data&quot;: arr,    &quot;name&quot;: &quot;李明&quot;,    &quot;pwd&quot;: &quot;123456&quot;});    }    client.end();});    }}</code></pre><p>在<code>views</code>文件夹中新建<code>book.jade</code>文件，在文件中写入如下内容</p><pre><code>// 继承默认布局模版extends layoutblock content  h1 图书信息列表  table   tr     th=&quot;ID&quot;     th=&quot;书名&quot;     th=&quot;作者&quot;     th=&quot;出版社&quot;     th=&quot;ISBN&quot;   //迭代后台传过来的数据    each item in data    tr     td=item.id     td=item.name     td=item.author     td=item.press     td=item.isbn</code></pre><blockquote><p>jade是express默认的模版渲染引擎，如果觉的这种代码方式不习惯，你也可以安装使用ejs模版引擎</p></blockquote><p>修改项目根目录的app.js文件在<code>var users = require('./routes/users');</code>后面添加</p><pre><code>var book = require('./routes/book');  #加载book路由</code></pre><p>在<code>app.use('/users', users);</code>后面添加</p><pre><code>app.use('/book', book)  #指定/book路径使用的路由</code></pre><p>简单修改下<code>table</code>和<code>h1</code>的样式，在<code>public/stylesheets/style.css</code>文件中添加如下代码</p><pre><code>h1{font-size:36px;}table,table td,table th {    border: 1px solid #999999;    border-collapse: collapse;    padding:10px;}table th{background-color: #e3e3e3;color: #cf4646;font-size:16px;font-family: '微软雅黑'}</code></pre><h2>第五步，启动项目，测试</h2><pre><code> supervisor ./bin/www        # 启动项目</code></pre><h2>第六步，测试结果</h2><pre><code>浏览器输入  http://localhost:3000/book/queryAll</code></pre><p><img src="/nodejs-express-mysql.jpg" alt="nodejs-express-mysq"></p><p>到此使用nodejs+express+mysql实现的简单数据<strong><em>单表数据全查</em></strong>操作已经完成。</p><h2>参考文档</h2><ul><li><p>jade模版引擎详细文档见 <a href="http://jade-lang.com/" rel="external nofollow noopener noreferrer" target="_blank"><strong>jade官网</strong></a></p></li><li><p>express详细文档见 <a href="http://www.expressjs.com.cn/" rel="external nofollow noopener noreferrer" target="_blank"><strong>express中文网</strong></a></p></li><li><p>node.js参考文档见 <a href="http://nodejs.cn/" rel="external nofollow noopener noreferrer" target="_blank"><strong>node.js中文网</strong></a></p></li></ul>]]></content>
    
    <summary type="html">
    
      Express连接mysql数据库实现简单的数据查询
    
    </summary>
    
      <category term="后端开发" scheme="https://www.wuhuan.me/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="node.js" scheme="https://www.wuhuan.me/tags/node-js/"/>
    
      <category term="mysql" scheme="https://www.wuhuan.me/tags/mysql/"/>
    
      <category term="express" scheme="https://www.wuhuan.me/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>ruby解析json</title>
    <link href="https://www.wuhuan.me/2015/09/25/ruby-json/"/>
    <id>https://www.wuhuan.me/2015/09/25/ruby-json/</id>
    <published>2015-09-25T08:39:36.000Z</published>
    <updated>2018-06-11T08:52:04.073Z</updated>
    
    <content type="html"><![CDATA[<p>做项目的时候需要一个小工具，为了方便就用ruby脚本写了一个小工具，这个小工具有个功能需要对json数据做解析，小工具实现了，顺便就把ruby中解析json的过程记录下来。</p><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，简单易用便于阅读和理解，最重要的是几乎所有的语言基本都支持json并且都有很多好用的解析工具，很多的api接口也都使用json作为数据交换格式。</p><p>&lt;!-- more --&gt;</p><h2>环境配置</h2><p>1.ruby编码解码json首先本地需要安装ruby的开发环境，安装方式有很多种，windows上建议下载<code>RubyInstaller for Windows</code>安装包进行安装。</p><p>2.通过gem的方式安装<code>json模块</code>，通过RubyInstaller安装的ruby中默认已经安装好了<code>rubygems</code></p><p><code>gem install json</code></p><h2>使用ruby解析json</h2><p><strong>需要解析的高三一班部分学生json格式数据,存储在<code>classInfo.json</code>文件中</strong></p><pre><code>[    {&quot;name&quot;: &quot;小美&quot;,&quot;class&quot;: &quot;高三一班&quot;&quot;id&quot;: &quot;1&quot;,&quot;phone&quot;: &quot;66666661&quot;    },    {&quot;name&quot;: &quot;小雷&quot;,&quot;class&quot;: &quot;高三一班&quot;,&quot;id&quot;: &quot;2&quot;,&quot;phone&quot;: &quot;66666662&quot;    },    {&quot;name&quot;: &quot;小红&quot;,&quot;class&quot;: &quot;高三一班&quot;,&quot;id&quot;: &quot;3&quot;,&quot;phone&quot;: &quot;66666663&quot;    }]</code></pre><p><strong>ruby脚本</strong></p><pre><code># encoding: utf-8require 'json'  #导入json模块require 'pp'json = File.read('classInfo.json')   #读取classInfo.json文件中的json字符串classInfo = JSON.parse(json)         #字符串转换为json对象pp classInfo                       #输出json对象# 迭代所有学生的信息puts  &quot;-------------学生信息如下--------------&quot;classInfo.each do |stu|puts stu[&quot;id&quot;]+&quot;   &quot;+stu[&quot;name&quot;]+&quot;  &quot;+stu[&quot;class&quot;]+&quot;    &quot;+stu[&quot;phone&quot;]endputs  &quot;---------------------------------------&quot;</code></pre><p><strong>输出结果</strong></p><pre><code>[{&quot;name&quot;=&gt;&quot;\u5C0F\u7F8E&quot;,  &quot;class&quot;=&gt;&quot;\u9AD8\u4E09\u4E00\u73ED&quot;,  &quot;id&quot;=&gt;&quot;1&quot;,  &quot;phone&quot;=&gt;&quot;66666661&quot;}, {&quot;name&quot;=&gt;&quot;\u5C0F\u96F7&quot;,  &quot;class&quot;=&gt;&quot;\u9AD8\u4E09\u4E00\u73ED&quot;,  &quot;id&quot;=&gt;&quot;2&quot;,  &quot;phone&quot;=&gt;&quot;66666662&quot;}, {&quot;name&quot;=&gt;&quot;\u5C0F\u7EA2&quot;,  &quot;class&quot;=&gt;&quot;\u9AD8\u4E09\u4E00\u73ED&quot;,  &quot;id&quot;=&gt;&quot;3&quot;,  &quot;phone&quot;=&gt;&quot;66666663&quot;}]-------------学生信息如下--------------1   小美  高三一班    666666612   小雷  高三一班    666666623   小红  高三一班    66666663---------------------------------------</code></pre><p><strong>Tips</strong></p><p><code>JSON.pretty_generate(json)</code>方法可以美化json输出</p>]]></content>
    
    <summary type="html">
    
      ruby解析json
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gulp使用笔记</title>
    <link href="https://www.wuhuan.me/2015/09/24/gulp-one/"/>
    <id>https://www.wuhuan.me/2015/09/24/gulp-one/</id>
    <published>2015-09-24T07:15:36.000Z</published>
    <updated>2018-11-01T03:11:31.441Z</updated>
    
    <content type="html"><![CDATA[<p>如果科学技术是第一生产力，那么客观需求就是学习的动力，也就是说学习一种新的东西知识首先要明白它的作用是什么，如果弄不清楚这个原因我们会去排斥学习它的，甚至根本不想去学习它。所以我们开始就来说说为什么要使用项目自动化构建工具，以及gulp的有点，本文仅仅是自己学习使用后的整理笔记，分享给还在使用手动构建项目和需要它的人们，所以高手可以略过......</p><p>&lt;!-- more --&gt;</p><h2>为什么要使用项目自动化构建工具？</h2><p>假如下面是我们正在做的一个项目的基本结构</p><pre><code>|-{project name}     |-source        |-js        |-css        |-images     |-dist        |-js        |-css        |-images     |-doc     |-test     |-index.html       .       .       .</code></pre><p>在开发的时候常会把<code>js,css,images</code>文件放在项目的<code>source文件夹</code>对应的文件夹中，当发布这个项目时候，有一下几点基本构建要求和步骤</p><ol><li>清理<code>dist/</code>目录下的所有文件</li><li><code>source/js</code>文件夹中的所有的<code>js文件</code>合并，压缩,改名为<code>mian.min.js</code>，同时保留一份未压缩的<code>main.js</code>，然后将这两个文件复制到<code>dist/js</code>中。</li><li><code>source/css</code>文件夹中的所有<code>css文件</code>合并，压缩,改名<code>style.min.css</code>，同时保留一份未压缩的<code>style.css</code>，然后将这两个文件复制到<code>dist/css</code>中。</li><li><code>source</code>中的所有的图片压缩之后复制到<code>dist</code>中</li><li>根目录中的所有的<code>html文件</code>压缩后复制到<code>dist目录</code>中</li></ol><p>如果项目中的文件很少我们可以手工一个一个去处理，<strong>但是</strong>如果项目中的<code>js,css,images,html</code>很多，那么手工处理会很<strong>无趣</strong>，而且极容易出错，而且实际的情况下构建任务远比这个复杂的多，比如有时候还要编译项目中<code>Sass</code>,<code>CoffceScript</code>等预编译语言文件，如果这个时候我们学会使用某种构建工具，那么我们会发现手工构建和自动构建就像是原始农耕走向了机械化生产......<strong><em>一旦遇见便会爱恋</em></strong>。</p><h2>gulp在项目构建上的优点</h2><p><code>gulp</code>是目前比较流行的前端项目构建工具，流行的前端框架<code>Angular</code>就是使用它构建的。经常拿他来做比较的前端构建工具还有<code>grunt</code>,著名的<code>jquery</code>就是用它构建的。</p><p><strong><em>1. gulp的api非常的简单，这也是我使用它的原因之一，掌握下面四个函数就可以使用gulp进行前端项目自动化构架了。</em></strong></p><ul><li><p><code>gulp.src(globs[, options])</code> 获取一个或一组虚拟文件流（Vinyl files）</p></li><li><p><code>gulp.dest(path[, options])</code> 写文件,并且重新输出（emits）所有数据到指定文件夹，文件夹如果不存在会自动创建</p></li><li><p><code>gulp.task(name[, deps], fn)</code> 定义一个任务，如果需要在命令行下运行某些任务，任务名中请不要用空格</p></li><li><p><code>gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])</code> 监视文件，并且可以在文件发生改动时候做一些事情</p><p><a href="http://www.gulpjs.com.cn/docs/api/" rel="external nofollow noopener noreferrer" target="_blank">详细api文档</a></p></li></ul><p><strong><em>2. 通过脚本代码的方式来构建任务，比配置文件的方式更加灵活方便</em></strong> <strong><em>3. 一个插件只完成一个功能，多个插件组合可以实现复杂的构建任务，而且代码比较清晰</em></strong> <strong><em>4. 基于流的方式，不会产生中间文件</em></strong></p><h2>gulp安装运行</h2><p>由于<code>gulp</code>是基于<code>node.js</code>的所以要在本机安装<code>node.js</code>的运行环境，<code>node.js</code>安装好了就可以使用<code>npm</code>来安装gulp了 <code>npm是node.js的包管理工具，安装node.js的时候就会默认安装</code></p><ol><li><p><strong>安装命令行工具</strong> <code>npm install -g gulp</code></p></li><li><p><strong>在项目下安装gulp依赖&lt;devDependencies&gt;组件</strong> <code>npm install gulp --save</code> <strong><em>-save和-save-dev</em></strong> <code>npm install module-name -save 自动把模块和版本号添加到dependencies部分</code> <code>npm install module-name -save-dev 自动把模块和版本号添加到devdependencies部分</code></p></li><li><p><strong>创建Gulpfile.js文件，初始内容为</strong></p><pre><code>var gulp = require('gulp');//加载gulp  gulp.task('default', function () {//执行默认任务//任务内容});</code></pre></li><li><p><strong>运行（在项目根目录下使用命令行运行如下命令）</strong> <code>gulp</code> <strong><em>执行指定任务</em></strong> <code>gulp &lt;task1&gt; &lt;task2&gt;</code></p></li></ol><p><strong>常用插件</strong></p><pre><code>sass的编译                   （gulp-ruby-sass）自动添加css前缀              （gulp-autoprefixer）压缩css                      （gulp-minify-css）js代码校验                   （gulp-jshint）合并js文件                   （gulp-concat）压缩js代码                   （gulp-uglify）压缩图片                     （gulp-imagemin）自动刷新页面                 （gulp-livereload）图片缓存，只有图片替换了才压缩（gulp-cache）更改提醒                    （gulp-notify）清除文件                    （del）html压缩                     （gulp-htmlmin）</code></pre>]]></content>
    
    <summary type="html">
    
      gulp使用笔记
    
    </summary>
    
      <category term="前端开发" scheme="https://www.wuhuan.me/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发工具" scheme="https://www.wuhuan.me/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>对编程语言的一些新的认识</title>
    <link href="https://www.wuhuan.me/2015/08/07/about-programming-language/"/>
    <id>https://www.wuhuan.me/2015/08/07/about-programming-language/</id>
    <published>2015-08-07T10:00:36.000Z</published>
    <updated>2018-06-11T08:52:04.073Z</updated>
    
    <content type="html"><![CDATA[<h2>编程语言</h2><p>编程语言（programming language），是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。</p><blockquote><p>PS:来自百度百科的解释</p></blockquote><h2>编程语言的分类</h2><p>我们可能经常会听见<strong>面向对象的编程语言</strong>，<strong>面向过程的编程语言</strong>，<strong>声明式编程语言</strong>，<strong>命令式编程语言</strong>，<strong>函数式编程语言</strong>，<strong>低级语言</strong>，<strong>高级语言</strong>等等，其实编程语言大体上可以分为**<code>静态编程语言</code><strong>,</strong><code>动态编程语言</code>**它们的区别如下：</p><ol><li><strong>静态语言需要编译后才能运行，动态语言通常情况下不用编译就可以直接解释运行</strong> 拿python来说吧，以<code>.py</code>结尾的python源文件可以直接解释运行，而以<code>.pyc</code>结尾python文件则是编译过的二进制文件，它是编译执行的，执行和加载效率要高于解释执行，但是像java这种静态语言就必须要编译成二进制文件在能在虚拟机上运行。</li><li><strong>静态语言在编译的时候已经知道变量的类型（强类型），动态语言在运行的时候才知道变量的具体类型（弱类型）</strong> PS:正是因为这样，我们在使用<code>javascript</code>,<code>ruby</code>,<code>python</code>等语言编程的时候是不用为变量声明具体的类型的，方便我们写代码。而像<code>c</code>,<code>c++</code>,<code>c#</code>等这些语言就不行。</li></ol><p>&lt;!-- more --&gt;</p><h2>面向过程的编程语言</h2><p>“面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。“面向过程”也可称之为“面向记录”编程思想，他们不支持丰富的“面向对象”特性（比如继承、多态），并且它们不允许混合持久化状态和域逻辑。就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 <code>PS:来自百度百科的解释</code></p><h2>面向对象的编程语言</h2><p>面向对象有三大基本特点<code>继承</code>,<code>封装</code>,<code>多态</code>。 <strong>继承</strong>：子类从父类那里派生得到，子类就具有了和父类相同的属性和方法，扩展已有的代码模块。 <strong>封装</strong>：把某一个过程抽象出来然后封装成一个方法，提供入口参数和出口参数，使用的时候只考虑功能不考虑内部是怎么实现的。这样使得程序修改带来的影响更加局部化。隐藏细节实现代码模块化。 <strong>多态</strong>：其实就是单接口多实现，子类覆盖父类中的方法，使用父类引用指向子类对象，再调用某一父类中的方法时，不同子类会表现出不同结果。 <strong>tips</strong>:<code>Don't Repeat Yourself原则------彻底避免重复</code>。</p><h2>原型方式和模版方式</h2><p>程序中我们会把一些具有相同功能的算法和代码抽象封装成为一个方法，提供入口参数和出口参数，这样在需要使用这个方法的功能的时候就不需要去写重复的代码，直接调用就可以了！在面向对象的语言中，如果同一个对象大量存在，为了避免重复我们是不是应该去怎么寻找一种和封装方法类似的办法来管理这些对象呢，可以采用下面两种方式。</p><ol><li><p>一种方式是使用原型的方式（现在流行网页脚本语言javascript使用的就是这种方式），使用原始对象的副本作为一个新的相同的对象。</p></li><li><p>另一种方式是使用模版的方式，这种方式就像我们做不同形状的曲奇饼干一样，使用相同模具最后做出来的东西的样子就是一样的，和原型不同的是面向对象中的类和对象有着完全的区别。就相当于模具和模具做出的饼干是有区别的，整数类和具体的数字1，狗类和具体的某一条狗，为了表示类和对象的不同，对象又被称作实例。</p></li></ol><h2>后记</h2><p>计算机是一种只能识别二进制如<code>01011000100</code>这样的指令，但是这种指令太抽象和我们使用的自然语言相差太大，所以不管编写，阅读的难度都是相当大的，有时候指令中可能多一个0或者少一个0那么执行出来的效果都相差好多好多，慢慢的汇编语言出现了，它是对二进制指令的一次抽象和封装，在慢慢的更高级一点的语言像<code>c语言</code>,<code>c++</code>,<code>java</code>这类语言开始被发明出来，这类语言不管是在源码的编写和阅读方面都是二进制指令有着天壤之别，这些语言已经是现在的主流开发语言，从这个线上面我们可以看出，编程语言的可操作性和可阅读性越来越简单，<strong>越来越符合我们使用的自然语言习惯</strong>这也是未来新型编程语言的一个发展趋势，未来的编程语言可能简单的和我们每天说话一样，人人都能编程!</p>]]></content>
    
    <summary type="html">
    
      随笔...
    
    </summary>
    
      <category term="个人随笔" scheme="https://www.wuhuan.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>对于系统登录流程的一些理解和总结</title>
    <link href="https://www.wuhuan.me/2014/07/15/login/"/>
    <id>https://www.wuhuan.me/2014/07/15/login/</id>
    <published>2014-07-15T06:25:36.000Z</published>
    <updated>2018-09-27T04:04:44.756Z</updated>
    
    <content type="html"><![CDATA[<h2>登录的意义</h2><p>我们常常会发现在一些网站上登录是非必须的，比如一些浏览性的网站（网易新闻，百度图片），但是用户在使用像QQ空间，微博，人人网等这些网站的时候必须要用户登录后才能使用！暂且不分析为什么有的网站需要登录有的不需要登录，这和每个网站的理念也是有关系的，所以我们只着重分析登录的作用和意义，在我看来登录的作用应该有以下几点：</p><ol><li><p>登录过程其实是一个对用户身份认证的过程，只有登录了系统，系统才会识别出你是谁，谁在使用自己！例如现在大数据时代已经到来，用户登录后才能分析每个用户的用户习惯！</p></li><li><p>登录过程后才能针对不同的用户进行相应的权限控制！例如一些OA系统登录用户不同那么登录成功后所看到的东西是不一样的。</p></li><li><p>登录过程后才能针对不同的用户产生的信息（资源）进行管理！例如像博客，sns,微博这样的网站登录后都会给你生成一个个人主页，你可以查看和修改自己的资源，也可以在别人的主页去查看别人你可以查看的资源</p></li></ol><p><strong>上面列举了这几点其实总结下核心就一条，“登录过程是区分系统与用户，用户与用户之间的唯一凭证”。</strong></p><blockquote><p>百度百科对于<strong>登录</strong>的解释：供多人使用的网站或程序应用系统为每位用户配置了一套独特的用户名和密码，用户可以使用各自的这套用户名和密码来使用系统，以便<strong>系统能识别该用户的身份</strong>，从而保持该用户的使用习惯或使用数据。用户使用这套用户名和密码来进入系统的过程，以及系统验证进入是成功或失败的过程，称为“登录”。</p></blockquote><p>&lt;!--more--&gt;</p><h2>登录流程</h2><p>一个简单的登录流程如下图所示，用户输入用户名和密码开始登录，用户名和密码传递到后台进行判断，密码正确进入系统，密码错误返回登录页面，重新输入用户名和密码进行登录。</p><p><img src="/login.jpg" alt="login"></p><h2>登录过程的安全性</h2><p>对于绝大多数网站和系统的登录过程是必须的而且在一个系统中是非常重要的，尤其像网上银行，支付宝，社交网站，这些网站上都有用户的敏感信息以及账户金额等信息，如果帐号别人盗用，那么后果是不堪设想的!所以登录过程的安全性尤为重要，当然用户因为其它原因泄漏密码和用户名的情况不再本文的讨论范围之内，下面针对登录流程中涉及到的安全性问题进行简单的说明！</p><h3>暴力破解</h3><p>上图简单的登录流程中其实是有很大的漏洞，因为可以在不知道用户名和密码的情况下进行无限次数的登录尝试，这样就可以用程序去写一个机器人去不断循环遍历密码进行暴力破解，下面我们就在这个基本的登录流程的基础上去一步步优化这个登录流程。</p><p>防止暴力破解现在很多网站用的一种方式就是在登录时候加一个图片验证码，加过验证码的登录流程图如下：</p><p><img src="/login1.jpg" alt="login"></p><p>加入图片验证码后每次登录时不但要输入用户名，密码，还要输入图片验证码上面的内容，然后把这些数据提交到后台，首先判断验证码是否正确，如果正确，程序就直接返回验证码有误,如果验证码正确，然后才判断用户名和密码是否正确，密码正确才进入系统。</p><p>修改后的登录流程已经可以防止暴力破解了，普通的系统和网站使用这样的方式已经可以了，但是对于银行和支付宝等这些安全性更高的网站来说还是不够的，那么银行和支付宝这些网站是怎么做的呢，限制用户密码输错的次数！下面看看如果这样修改后系统的登录流程。流程图如下：</p><p><img src="/login2.jpg" alt="login"></p><p>经过修改后的流程图中可以看出，即使可以伪造或者读取验证码绕过验证码这一层，那么最多也就10次尝试的机会，输错10次后今天就不能在登录了。</p><h3>sql注入</h3><p>通过上面登录流程的修改暴力破解已经得到了有效的控制，但是还有一个安全性的问题那就是sql注入，不过现在的网站上已经很少存在这种情况了，sql注入这一块主要注意的就是要把用户的输入中的特殊的字符给过滤掉，sql语句中需要的值通过参数的形式传递进去，不要用字符串的形式去拼一个sql语句，由于这块涉及到具体的编程一两句话也说不清楚就不详细写了，<strong>只要保证用户输入的数据是合法的，那么就不会存在SQL注入</strong>。</p><h3>网络传输的安全性</h3><p>传统的HTTP协议在网络中传输数据的时候都是明文传输，那么通过网络抓包工具抓住登录时候发送的数据包那么就可以获取里面的明文的用户名和密码，所以登录使用HTTPS(安全的超文本传输协议)，使用HTTPS后即使通过网络抓包工具抓到数据包，那么数据包里面的内容也是加过密的，是没有利用价值的。</p><h2>登陆过程中的用户体验</h2><p>安全性很重要，上面改进过的登录过程已经很安全了，至少不会存在暴力破解了，但是用户体验在现在的互联网中也是很重要的，所以我们就要在安全性和用户体验中寻找一个平衡点，所以还要对上面的安全验证做一些改进，以至于达到我们理想的需求。</p><p>对用户体验的改进目前就想到了验证码，比如当用户名或者密码输错3次后才显示验证码，这样子对于真正的用户来说，避免了他输入没有意义的验证码。</p><h2>总结</h2><p>通过安全性和用户体验对登录流程做了一些简单介绍，这些都是在实际的项目中和在使用别人的软件的时候总结出来的，当然具体实现的时候还有很多的具体的细节需要去注意和完善。任何一个小的系统或者模块把它做好，做到极致都是不容易的，你需要去花费很多的时间和精力去设计它。</p><h2>后记</h2><ul><li><p>使用单点登录，这样同一时刻一个账户只能在一个地方登录，当你登录系统的时候，过一会发现自己被踢下线，那么说明你的帐号已经在别处登录，如果不是用户自己在其它浏览器中登录，那么用户就应该想到自己的账户是否已经被盗！</p></li><li><p>国外的一些网站，如google,dropbox,evernote等，都有一个二次验证机制，当用户正确输入用户名称和密码的时候，如果用户开启了二次验证，还会要求用户输入一个手机接收到的具有有效期的验证码！evernote的这项服务需要高级用户才能使用。</p></li><li><p>有一些网站的验证码不是纯碎的一些字母，而是一个问题或者一道数学题，比如5+7=？用户只需要填写答案就行，这也有效的提高了破解验证码的难度。</p></li><li><p>网易将军令这种动态密码保护器也是有效降低帐号被盗风险的一种好的方式。</p></li><li><p>在设计<strong>记住密码</strong>这个功能的时候，一定不要把用户的密码保存到本地，即使是加过密的密码！</p></li></ul>]]></content>
    
    <summary type="html">
    
      对于系统登录流程的一些理解和总结
    
    </summary>
    
      <category term="产品思考" scheme="https://www.wuhuan.me/categories/%E4%BA%A7%E5%93%81%E6%80%9D%E8%80%83/"/>
    
    
      <category term="用户体验" scheme="https://www.wuhuan.me/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
      <category term="网站安全" scheme="https://www.wuhuan.me/tags/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8/"/>
    
      <category term="系统设计" scheme="https://www.wuhuan.me/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="心得总结" scheme="https://www.wuhuan.me/tags/%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
